## Codebase Patterns
- **XLSX embedded charts**: `extract_charts_from_zip(data: &[u8]) -> Vec<Chart>` scans `xl/charts/chart*.xml` entries in ZIP archive via `zip::ZipArchive`. Parses each with `chart::parse_chart_xml()`. Charts appended as `Page::Flow(FlowPage { content: vec![Block::Chart(chart)] })` after all TablePages. Test: `build_xlsx_with_chart()` creates XLSX via umya-spreadsheet, re-opens ZIP to inject chart XML entry at `xl/charts/chart1.xml`.
- **PDF/A output**: `compile_to_pdf(source, images, pdf_standard: Option<PdfStandard>)`. When `Some(PdfStandard::PdfA2b)`, creates `typst_pdf::PdfStandards::new(&[typst_pdf::PdfStandard::A_2b])` and provides `typst_pdf::Timestamp::new_utc(Datetime)` (PDF/A requires a document date). `ConvertOptions.pdf_standard` threaded from `convert_bytes()` to `compile_to_pdf()`. `render_document()` always passes `None` (backward compat). CLI: `--pdf-a` flag sets `PdfStandard::PdfA2b`. Verify: PDF/A output contains `pdfaid` in XMP metadata.
- **XLSX conditional formatting**: `sheet.get_conditional_formatting_collection()` → `&[ConditionalFormatting]`. Each CF has `get_sequence_of_references().get_sqref()` (space-separated ranges like "A1:C3 D5") and `get_conditional_collection()` (rules). `ConditionalFormattingRule`: `get_type()` → `ConditionalFormatValues::{CellIs, ColorScale, ...}`, `get_operator()` for CellIs, `get_formula()` → formula value via `f.get_address_str()`, `get_style()` for formatting, `get_color_scale()` for color scales. `CondFmtOverride { background, font_color, bold }`. `build_cond_fmt_overrides(sheet)` → `HashMap<(col,row), CondFmtOverride>`. Applied in cell loop after normal style extraction. Color scale: `ColorScale.get_color_collection()` for gradient colors, `interpolate_color(a, b, ratio)` for blending. Test creation: `ConditionalFormattingRule::default().set_type(CellIs).set_operator(GreaterThan).set_formula(formula).set_style(style)`, wrap in `ConditionalFormatting` with `SequenceOfReferences::default().set_sqref("A1:A3")`, apply via `sheet.set_conditional_formatting_collection(vec![cf])`.
- **PPTX group shapes**: `<p:grpSp>` contains `<p:nvGrpSpPr>`, `<p:grpSpPr>` (with `<a:xfrm>` holding off/ext/chOff/chExt), then child shapes (sp, pic, grpSp, graphicFrame). `parse_group_shape(&mut reader, xml, images, theme)` called from `parse_slide_xml` when `grpSp` Start is encountered. Reads header sections, extracts `GroupTransform`, then uses `reader.buffer_position() as usize` to slice child XML from original `xml: &str`, wraps in namespace container `<r xmlns:a="..." xmlns:r="..." xmlns:p="...">...</r>`, and recursively calls `parse_slide_xml()`. Transform: `slide_x = off_x + (child_x - chOff_x) * (ext_cx / chExt_cx)`. Division-by-zero guarded with fallback to scale 1.0. Handles nested groups naturally via recursion. Test helper: `make_group_shape(off_x, off_y, ext_cx, ext_cy, ch_off_x, ch_off_y, ch_ext_cx, ch_ext_cy, &children)`.
- **DOCX SDT/TOC handling**: `DocumentChild::StructuredDataTag` wraps content in SDTs (including TOC). `convert_sdt_children()` recursively extracts `Paragraph`, `Table`, and nested `StructuredDataTag` children. Processes each through the standard pipeline (convert_paragraph_element, convert_table). TOC cached content renders as static paragraphs — no special IR type needed. docx-rs reads TOC as SDT (reader-only); `DocumentChild::TableOfContents` is builder-only. Test TOC creation: `Docx::new().add_table_of_contents(TableOfContents::new().heading_styles_range(1,3).add_item(TableOfContentsItem::new().text("...").toc_key("_TocN").level(1).page_ref("2")))`. Test SDT creation: `Docx::new().add_structured_data_tag(StructuredDataTag::new().add_paragraph(para))`. Field code runs (fldChar/instrText) inside SDT produce empty text via `extract_run_text()` — no filtering needed.
- **DOCX footnotes/endnotes**: docx-rs reader does NOT parse `w:footnoteReference`/`w:endnoteReference` — must extract from raw ZIP. `NoteContext` struct holds: `footnote_content: HashMap<usize, String>`, `endnote_content: HashMap<usize, String>`, `note_refs: Vec<(NoteKind, usize)>`, `cursor: Cell<usize>`. Built by `build_note_context(data)` which opens ZIP, parses `word/footnotes.xml` + `word/endnotes.xml` via `parse_notes_xml()`, and scans `word/document.xml` via `scan_note_refs()`. Detection: `is_note_reference_run()` checks `run.run_property.style.val == "FootnoteReference"|"EndnoteReference"` + empty text. Correlation: `consume_next()` advances cursor through ordered note refs. IR: `Run.footnote: Option<String>`. Typst: `#footnote[escaped_content]` in `generate_run()`. Test footnotes: `docx_rs::Run::new().add_footnote_reference(Footnote::new().add_content(para))`. Test endnotes: manually build DOCX ZIP with `zip::ZipWriter` including `word/endnotes.xml` and `<w:endnoteReference>` in document.xml.
- **DOCX hyperlinks**: `ParagraphChild::Hyperlink(Hyperlink)` wraps child runs. `Hyperlink.link`: `HyperlinkData::External { rid, path }` (path empty on read-back) or `HyperlinkData::Anchor { anchor }` (internal). Reader stores URLs in `docx.hyperlinks: Vec<(rid, url, type)>` — use this to build `HyperlinkMap`. `HyperlinkMap` threaded through parser pipeline (parse → convert_paragraph_element → convert_paragraph_blocks → convert_table → extract_raw_rows → extract_cell_content). `resolve_hyperlink_url()` maps rid → URL. Run IR has `href: Option<String>`. Typst codegen wraps with `#link("url")[content]` in `generate_run()`. Test: `Hyperlink::new("url", HyperlinkType::External).add_run(Run::new().add_text("text"))`, `Paragraph::new().add_hyperlink(link)`.
- **CLI batch conversion**: CLI accepts `inputs: Vec<PathBuf>` for multiple files. `--outdir` flag specifies output directory (conflicts_with `--output`). `determine_output_path(input, output, outdir)` resolves output path: explicit `--output` > `--outdir` + filename.pdf > input.with_extension("pdf"). `convert_batch(inputs, outdir, options)` returns `BatchResult { succeeded, failed }` with per-file error handling. Summary printed for multi-file runs. `--outdir` auto-creates directory via `create_dir_all`. `--output` only valid with single input. Test fixture creation: `docx_rs` as dev-dep on CLI crate.
- **ConvertOptions threading**: `Parser::parse(&self, data: &[u8], options: &ConvertOptions)` — all parsers accept options. XLSX uses `options.sheet_names` to filter sheets. PPTX uses `options.slide_range` to filter slides. DOCX ignores options. `convert_bytes()` passes options to parser. CLI builds ConvertOptions from `--sheets` (comma-separated) and `--slides` (range "1-5" or single "3") flags.
- **XLSX cell formatting**: `cell.get_style()` → `&Style`. Font: `style.get_font()` → `Option<&Font>` with `get_name()`, `get_size()`, `get_bold()`, `get_italic()`, `get_underline()`, `get_strikethrough()`, `get_color().get_argb()`. Background: `style.get_background_color()` → `Option<&Color>` with `get_argb()` (ARGB 8-char hex, skip first 2 for alpha). Borders: `style.get_borders()` → `Option<&Borders>` with `get_top/bottom/left/right()` → `&Border` with `get_border_style()` (str) and `get_color().get_argb()`. Border widths: hair=0.25pt, thin=0.5pt, medium=1.0pt, thick=2.0pt. Row height: `sheet.get_row_dimension(&row_idx)` → `Option<&Row>` with `get_height()` and `get_custom_height()`. Test setup: `cell.get_style_mut().get_font_mut().set_bold(true)`, `style.set_background_color("FFFFFF00")`, `style.get_borders_mut().get_bottom_mut().set_border_style("medium")`, `sheet.get_row_dimension_mut(&1).set_height(30.0)`. Defaults to skip: font name "Calibri", size 11.0, color "FF000000".
- **XLSX number formats**: Use `cell.get_formatted_value()` instead of `cell.get_value().to_string()` to get pre-formatted cell text. umya-spreadsheet handles all formatting internally: currency ($#,##0.00), percentage (0%), dates (yyyy-mm-dd), thousands separators (#,##0), custom format strings. Set format: `cell.get_style_mut().get_number_format_mut().set_format_code("format")` or `.set_number_format_id(id)`. Built-in format IDs: 0=General, 1=0, 2=0.00, 3=#,##0, 4=#,##0.00, 9=0%, 10=0.00%, 14=m/d/yyyy. For dates: use `set_value_number(serial)` where serial is Excel date serial (days since 1900-01-01). "General" format passes through simple numbers unchanged. Constants: `NumberingFormat::FORMAT_CURRENCY_USD_SIMPLE`, `FORMAT_PERCENTAGE`, `FORMAT_DATE_YYYYMMDD`, etc.
- **DOCX document styles**: `docx.styles.styles` is `Vec<Style>` with `style_id`, `name`, `style_type`, `run_property`, `paragraph_property`. Access via `docx.styles`. `ParagraphProperty.style: Option<ParagraphStyle>` stores the pStyle reference; `ParagraphStyle.val` is the style ID string. `Style.paragraph_property.outline_lvl: Option<OutlineLvl>` with `OutlineLvl.v: usize` (public) for heading level detection (0=H1..5=H6). `Name.name` is private — use `serde_json::to_value(&name)` → string. Create test styles: `Style::new("Heading1", StyleType::Paragraph).name("Heading 1").outline_lvl(0).bold().size(48)`. Apply to paragraph: `Paragraph::new().style("Heading1")`. The `build_style_map()` function builds `StyleMap` (HashMap<String, ResolvedStyle>) from docx styles. `merge_text_style()` and `merge_paragraph_style()` merge style defaults with explicit formatting (explicit wins). Heading defaults (when style doesn't specify): H1=24pt, H2=20pt, H3=16pt, H4=14pt, H5=12pt, H6=11pt, all bold.
- **XLSX print area**: Print areas are stored as `DefinedName` with name `_xlnm.Print_Area` on worksheets. Use `sheet.get_defined_names()` to iterate, check `dn.get_name() == "_xlnm.Print_Area"`, parse address via `parse_print_area_range()`. Address format: `Sheet1!$A$1:$C$10` (sheet prefix optional, dollar signs optional). `parse_column_letters("AA")` → 27, `parse_cell_ref("$A$1")` → (1, 1). Test creation: `sheet.add_defined_name("_xlnm.Print_Area", "Sheet1!$A$1:$B$2")`.
- **XLSX page breaks**: `sheet.get_row_breaks().get_break_list()` → `&[Break]`. Filter `b.get_manual_page_break() == true`. `b.get_id()` is the 1-indexed row number (break occurs after that row). `collect_row_breaks()` returns sorted, deduped Vec<u32>. Split rows into multiple TablePages at break points. Test creation: `let mut brk = Break::default(); brk.set_id(row); brk.set_manual_page_break(true); sheet.get_row_breaks_mut().add_break_list(brk);`.
- **XLSX sheet headers/footers**: `sheet.get_header_footer()` → `&umya_spreadsheet::HeaderFooter`. `hf.get_odd_header().get_value()` / `hf.get_odd_footer().get_value()` returns Excel format string. Format codes: `&L`/`&C`/`&R` (section switches), `&P` (page number), `&N` (total pages), `&&` (literal ampersand), `&"FontName"` (font, skipped), `&NN` (font size, skipped). `parse_hf_format_string()` parses into `Option<HeaderFooter>` with sentinel chars (\x01=PageNumber, \x02=TotalPages). Test setup: `sheet.get_header_footer_mut().get_odd_header_mut().set_value("&CHeader Text")`.
- **Typst compilation**: Use `MinimalWorld` struct implementing `World` trait. `FontSearcher::new().include_system_fonts(true).search()` discovers system fonts with embedded fallbacks (Libertinus Serif, New Computer Modern, DejaVu Sans Mono via `embed-fonts` feature). For custom font dirs, use `searcher.search_with(paths)` — highest priority. Create `Source` with `FileId::new(None, VirtualPath::new("main.typ"))`. `compile_to_pdf(source, images, pdf_standard, font_paths)` threads font_paths to MinimalWorld.
- **Page size / landscape override**: `ConvertOptions.paper_size: Option<PaperSize>` (A4/Letter/Legal/Custom), `landscape: Option<bool>`. `resolve_page_size(original, options)` applies overrides: paper_size replaces dimensions, landscape swaps w/h when needed. Called in each page generator (flow/fixed/table). `generate_typst_with_options(doc, options)` is the options-aware codegen; `generate_typst(doc)` uses default options. `PaperSize::parse("a4"|"letter"|"legal")` for CLI.
- **DOCX list detection**: Check `para.has_numbering` and `para.property.numbering_property` for `NumberingProperty { id: Option<NumberingId>, level: Option<IndentLevel> }`. `NumberingId.id` is the numId, `IndentLevel.val` is the ilvl (0-based). numId=0 means "no numbering". Resolve numId → abstractNumId via `docx.numberings.numberings`, then check `abstract_num.levels[0].format` (use serde) for `"bullet"` (Unordered) vs `"decimal"`/etc. (Ordered). Group consecutive list paragraphs with same numId into `Block::List`.
- **Typst list codegen**: Use `#list(list.item[content], ...)` for unordered, `#enum(enum.item[content], ...)` for ordered. Nested items: emit a sub-list `[#list(...)]` after the parent item. The `generate_list_items()` function recursively handles nesting based on item levels.
- **docx-rs test list creation**: `docx_rs::Paragraph::new().add_run(...).numbering(NumberingId::new(1), IndentLevel::new(0))`. Need `AbstractNumbering::new(id).add_level(Level::new(level, Start::new(1), NumberFormat::new("bullet"|"decimal"), LevelText::new("•"|"%1."), LevelJc::new("left")))` and `Numbering::new(numId, abstractNumId)`, wrapped in `Numberings::new().add_abstract_numbering(an).add_numbering(n)` and set via `Docx::new().numberings(nums)`.
- **Typst codegen structure**: Each FlowPage emits `#set page(...)` then paragraphs. Text runs use `#text(props)[content]` for styling. Underline/strikethrough wrap with `#underline[...]`/`#strike[...]`. Special chars (`#`, `*`, `_`, `$`, etc.) must be escaped with `\`.
- **IR module imports**: Style types (Alignment, Color, TextStyle, ParagraphStyle, LineSpacing) are re-exported via `crate::ir::*` — do NOT import from `crate::ir::style::` (private module).
- **Quality gates**: Always run `cargo fmt --all -- --check`, `cargo clippy --workspace -- -D warnings`, `cargo test --workspace`, `cargo check --workspace` before committing. Use `writeln!` not `write!(...\n)` per clippy.
- **f64 formatting**: Use helper `format_f64()` to strip unnecessary trailing zeros (e.g., `72` not `72.0`).
- **Pipeline testing**: Use `office2pdf::render_document(&doc)` to test IR → PDF without needing parsers. Construct `Document` with mock `FlowPage`/`FixedPage`/`TablePage` data.
- **DOCX headers/footers**: Access via `docx.document.section_property.header` (and `.footer`) — `Option<(String, Header)>`. `Header.children` contains `HeaderChild::Paragraph(Box<Paragraph>)`. Similarly for `Footer`. Use `Docx::new().header(header).footer(footer)` to create test docs.
- **DOCX field codes round-trip**: When docx-rs builds and then reads back, `InstrText::PAGE` becomes `RunChild::InstrTextString("PAGE")` (not `RunChild::InstrText`). Always check both `InstrText` and `InstrTextString` variants.
- **FieldChar direct access**: `FieldChar.field_char_type` is public (`docx_rs::FieldCharType::{Begin,Separate,End}`). No need for serde — access directly.
- **Typst context for counters**: `#counter(page).display()` requires a `context` expression in Typst 0.14. Emit `context [...]` when header/footer contains page numbers.
- **FlowPage header/footer**: `FlowPage` has `header: Option<HeaderFooter>` and `footer: Option<HeaderFooter>`. Set to `None` for no header/footer. `HeaderFooter { paragraphs: Vec<HeaderFooterParagraph> }` with `HFInline::Run(Run)` for text and `HFInline::PageNumber` for page number fields.
- **Typst table codegen**: Use `#table(columns: (Wpt, ...), ...)` with cells as `[content]` (simple) or `table.cell(props)[content]` (when colspan/rowspan/fill/stroke needed). Cell content uses `generate_run()` directly (no block wrapper). Borders: `stroke: (top: 1pt + rgb(r, g, b), ...)`. Background: `fill: rgb(r, g, b)`. Merging: `colspan: N`, `rowspan: N`.
- **docx-rs reading**: `docx_rs::read_docx(&[u8])` → `Docx`. Access `docx.document.children` (Vec<DocumentChild>). Paragraphs: `DocumentChild::Paragraph(Box<Paragraph>)`. Runs: `ParagraphChild::Run(Box<Run>)`. Text: `RunChild::Text(Text)` → `t.text`. Tab: `RunChild::Tab`. Break: `RunChild::Break`.
- **docx-rs private fields**: `PageSize` (w, h), `Bold` (val), `Italic` (val), `Sz` (val), `Color` (val), `Underline` (val), `RunFonts` (ascii, hi_ansi, etc.) all have private fields. Use `serde_json::to_value()` to extract values since they implement Serialize. **IMPORTANT**: These types serialize as their *direct inner value* (e.g. `Bold` → `true`, `Sz` → `24`, `Color` → `"FF0000"`), NOT as `{"val": ...}`. Use `json.as_bool()`, `json.as_f64()`, `json.as_str()` directly. `RunFonts` serializes as an object with `ascii`, `hi_ansi`, etc. fields. `Strike` has `pub val: bool` — accessible directly without serde.
- **DOCX units**: Page size and margins in OOXML are in twips (1 twip = 1/20 pt). Convert: `value_twips / 20.0 = points`. PageMargin fields are public i32. docx-rs default page size: 11906 x 16838 twips (A4).
- **DOCX page orientation**: `extract_page_size()` reads orient via `serde_json::to_value(&page_size).get("orient")`. If orient is `"landscape"` and width < height, dimensions are swapped. Note: docx-rs reader does NOT populate orient from XML — only the builder does. Real DOCX files already have swapped w/h for landscape. For test creation: `Docx::new().page_size(16838, 11906).page_orient(docx_rs::PageOrientationType::Landscape)`.
- **Test DOCX creation**: Use `docx_rs::Docx::new().add_paragraph(...)`, then `.build().pack(&mut Cursor::new(Vec::new()))` to get bytes. Use `Cursor::into_inner()` to extract.
- **Typst FixedPage codegen**: Slides use `#set page(width: Wpt, height: Hpt, margin: 0pt)`. Elements use `#place(top + left, dx: Xpt, dy: Ypt)[...]` for absolute positioning. TextBox wraps content in `#block(width: Wpt, height: Hpt)[...]`. Shapes: `#rect(width, height, fill?, stroke?)`, `#ellipse(...)`, `#line(start, end, stroke?)`. Images use existing `generate_image()` inside place.
- **umya-spreadsheet merge API**: `sheet.get_merge_cells()` → `&[Range]`. Range has `get_coordinate_start_col/row()` and `get_coordinate_end_col/row()` → `Option<&ColumnReference/RowReference>`. Use `*ref.get_num()` for 1-indexed u32 coordinate. `sheet.add_merge_cells("A1:C5")` for test creation. Must expand `get_highest_column_and_row()` grid to include merge extents since that method only considers cells with data.
- **umya-spreadsheet reading**: `umya_spreadsheet::reader::xlsx::read_reader(Cursor::new(data), true)` → `Spreadsheet`. Sheets: `book.get_sheet_collection()`. Sheet name: `sheet.get_name()`. Cell: `sheet.get_cell((col, row))` → **IMPORTANT: tuple is (column, row), NOT (row, column)**. Cell value: `cell.get_value().to_string()`. Dimensions: `sheet.get_highest_column_and_row()` → `(max_col, max_row)`. Column width: `sheet.get_column_dimension_by_number(&col)` → `Option<&Column>`, then `col.get_width()` (Excel char units, ×7.0 → points).
- **Test XLSX creation**: `umya_spreadsheet::new_file()` → `Spreadsheet`. Set cell: `sheet.get_cell_mut("A1").set_value("text")`. Write: `umya_spreadsheet::writer::xlsx::write_writer(&book, &mut Cursor::new(Vec::new()))`. Multi-sheet: first sheet via `book.get_sheet_mut(&0)`, additional via `book.add_sheet(Worksheet::default())`.
- **Typst TablePage codegen**: `generate_table_page()` calls `write_page_setup()` + `generate_table()`. Reuses all existing table infrastructure (cell merging, borders, backgrounds, column widths). TablePage = page setup + a single Table element.
- **PPTX parsing**: Use `zip` + `quick-xml` (both already transitive deps, no new downloads). PPTX is a ZIP: `ppt/presentation.xml` (slide size + slide refs via `<p:sldSz cx cy>` + `<p:sldId r:id>`), `ppt/_rels/presentation.xml.rels` (rId → slide path), `ppt/slides/slideN.xml` (shapes). Parse with `ZipArchive::new(Cursor::new(data))` → `read_zip_entry()` → `quick_xml::Reader::from_str()`.
- **PPTX slide XML structure**: Shapes at `<p:spTree>/<p:sp>`. Position/size: `<a:xfrm><a:off x y/><a:ext cx cy/></a:xfrm>` (EMU ÷ 12700 = points). Text: `<p:txBody>/<a:p>/<a:r>/<a:t>`. Run props: `<a:rPr b="1" i="1" u="sng" strike="sngStrike" sz="1800">` (sz in hundredths of pt). Font color: `<a:solidFill><a:srgbClr val="RRGGBB"/></a:solidFill>`. Font family: `<a:latin typeface="..."/>`. Para alignment: `<a:pPr algn="ctr|l|r|just"/>`.
- **Test PPTX creation**: Build ZIP in-memory with `zip::ZipWriter::new(Cursor::new(Vec::new()))`. Need `[Content_Types].xml`, `_rels/.rels`, `ppt/presentation.xml`, `ppt/_rels/presentation.xml.rels`, and `ppt/slides/slideN.xml`. Standard 4:3 size: 9144000 × 6858000 EMU = 720pt × 540pt.
- **quick-xml 0.38 API**: Use `Reader::from_str(xml)`, `reader.read_event()` → `Event::Start/Empty/End/Text/Eof`. `BytesText::xml_content()` (NOT `unescape()`!) for text decoding. `BytesStart::local_name().as_ref()` for element name. Attributes: iterate `e.attributes().flatten()`, match `attr.key.as_ref()` (full name like `r:id`) or `attr.key.local_name().as_ref()` (local). `attr.unescape_value()` for string values.
- **PPTX shapes**: `<p:sp>` without text body → Shape IR element. Geometry from `<a:prstGeom prst="rect|ellipse|line">`. Fill color: `<p:spPr><a:solidFill><a:srgbClr val="RRGGBB"/></a:solidFill>`. Border: `<a:ln w="12700"><a:solidFill>...</a:solidFill></a:ln>` (w in EMU, ÷12700 → pt). Use `SolidFillCtx` enum to distinguish shape fill vs line fill vs run fill contexts.
- **PPTX images**: `<p:pic>` element. Position/size from `<p:spPr><a:xfrm>`. Image ref: `<a:blip r:embed="rId3"/>`. Resolve rId via slide .rels file (`ppt/slides/_rels/slideN.xml.rels`), then read image bytes from ZIP. Image format detected from file extension.
- **PPTX slide .rels**: Path pattern: `ppt/slides/_rels/slideN.xml.rels`. Image targets are relative paths like `../media/image1.png`. Use `resolve_relative_path()` to compute full ZIP path from slide directory.
- **docx-rs image handling**: Images in document tree: `RunChild::Drawing(Box<Drawing>)` → `Drawing.data = Some(DrawingData::Pic(pic))`. Image binary data: stored in `Docx.images` as `Vec<(id, path, Image, Png)>` — match `pic.id` to look up data. `pic.image` is empty when reading (only used during writing). Dimensions: `pic.size = (w_emu, h_emu)` in EMU. Convert: EMU ÷ 12700 = points. All images converted to PNG by docx-rs.
- **Test images for docx-rs**: Use `make_test_bmp()` to create a minimal 1×1 BMP, then `Pic::new(&bmp_data)` which processes through the `image` crate. Do NOT use `Pic::new_with_dimensions()` with raw PNG bytes for round-trip tests — the `image` crate may fail to decode minimal hand-crafted PNGs during `read_docx()`.
- **Image codegen**: `generate_typst()` returns `TypstOutput { source: String, images: Vec<ImageAsset> }`. Images get virtual paths `img-N.ext` via `GenCtx`. `compile_to_pdf(source, &images)` passes images to `MinimalWorld` which serves them via `World::file()`. Image markup: `#image("img-0.png", width: Wpt, height: Hpt)`.
- **Valid test PNG**: For tests that compile Typst with images, use `make_test_png()` helper which builds a 1x1 PNG with correct CRC32 checksums. For codegen-only tests, any byte slice works since Typst doesn't validate during codegen.
- **Parser trait returns warnings**: `Parser::parse()` returns `Result<(Document, Vec<ConvertWarning>), ConvertError>`. Destructure with `let (doc, _warnings) = parser.parse(&data)?;` in existing tests.
- **ConvertResult**: Public API (`convert`, `convert_bytes`) returns `ConvertResult { pdf: Vec<u8>, warnings: Vec<ConvertWarning> }` instead of bare `Vec<u8>`. Access PDF bytes via `.pdf`.
- **PPTX per-slide error recovery**: Each slide is parsed independently via `parse_single_slide()`. If a slide fails (missing file, broken XML), a warning is emitted and the slide is skipped.
- **DOCX per-element error recovery**: Each `DocumentChild` is processed inside `std::panic::catch_unwind`. If an element panics, a warning is emitted and processing continues.
- **PPTX theme parsing**: `ThemeData` struct holds `colors: HashMap<String, Color>`, `major_font: Option<String>`, `minor_font: Option<String>`. Parsed from `ppt/theme/theme1.xml` via `parse_theme_xml()`. Theme file located via presentation.xml.rels (relationship type containing "theme"). Color scheme elements: `dk1`, `dk2`, `lt1`, `lt2`, `accent1`-`accent6`, `hlink`, `folHlink`. Colors can be `<a:srgbClr val="RRGGBB"/>` or `<a:sysClr lastClr="RRGGBB"/>`. Font scheme: `<a:majorFont><a:latin typeface="..."/>` and `<a:minorFont><a:latin typeface="..."/>`.
- **PPTX scheme color resolution**: In slide XML, `<a:schemeClr val="accent1"/>` resolves to RGB via `theme.colors.get(&scheme_name)`. Handled in both Start and Empty events (schemeClr can have children like `<a:tint/>`). When no theme is loaded, scheme colors resolve to `None`.
- **PPTX theme font resolution**: `<a:latin typeface="+mj-lt"/>` → major font, `<a:latin typeface="+mn-lt"/>` → minor font. `resolve_theme_font()` substitutes these references. Explicit font names pass through unchanged.
- **Test PPTX with theme**: Use `build_test_pptx_with_theme(cx, cy, slides, theme_xml)`. Includes `ppt/theme/theme1.xml` in ZIP and theme relationship in presentation.xml.rels. `make_theme_xml(colors, major_font, minor_font)` creates theme XML. `standard_theme_colors()` returns Office-like defaults.
- **PPTX slide backgrounds**: `FixedPage.background_color: Option<Color>`. Parsed from `<p:bg><p:bgPr><a:solidFill>` in slide XML via `parse_background_color(xml, theme)`. Supports `<a:srgbClr>` and `<a:schemeClr>`. Inheritance chain: slide → layout → master via `resolve_inherited_background()`. Layout path from slide .rels (relationship target containing "slideLayout"), master path from layout .rels (target containing "slideMaster"). Typst codegen: `#set page(..., fill: rgb(r, g, b))` when background_color is Some.
- **Test PPTX with layout/master**: Use `build_test_pptx_with_layout_master(cx, cy, slide_xml, layout_xml, master_xml)`. Creates full inheritance chain: slide1 → slideLayout1 → slideMaster1 with .rels files at each level. `make_slide_xml_with_bg(bg_xml, shapes)` creates slide XML with `<p:bg>` inside `<p:cSld>`.
- **PPTX layout/master element inheritance**: `parse_single_slide()` resolves layout and master paths via `resolve_layout_master_paths()`, then parses elements from master, layout, and slide in order (master behind → layout → slide on top). Uses `rels_path_for()` helper for .rels path construction. `parse_slide_xml()` works on any XML with `<p:spTree>` — same function parses slide, layout, and master shapes. Test helpers: `make_layout_xml(shapes)`, `make_master_xml(shapes)`, `build_test_pptx_with_layout_master_multi_slide(cx, cy, slides, layout, master)` for multi-slide testing.
- **PPTX tables**: Tables live inside `<p:graphicFrame>` elements (not `<p:sp>`). Position from `<p:xfrm>` (not `<a:xfrm>`). Table XML: `<a:graphic><a:graphicData><a:tbl>`. Grid: `<a:tblGrid><a:gridCol w="EMU"/>`. Rows: `<a:tr h="EMU">`. Cells: `<a:tc>` with optional `gridSpan` (colspan), `rowSpan`, `hMerge`/`vMerge` (continuation). Cell content: `<a:txBody>` with same paragraph/run structure as shapes. Cell properties: `<a:tcPr>` with `<a:solidFill>` for background, `<a:lnL/lnR/lnT/lnB w="EMU">` for borders. Maps to `FixedElementKind::Table(Table)` in IR. `parse_pptx_table()` is a standalone sub-parser called from `parse_slide_xml()` when `<a:tbl>` is found. Test helpers: `make_table_graphic_frame(x, y, cx, cy, col_widths_emu, rows_xml)`, `make_table_row(cells_text)`, `table_element(elem)`.
- **DOCX OMML math equations**: docx-rs v0.4.19 does NOT parse `m:` namespace elements — they are completely absent from `ParagraphChild`/`RunChild` enums. Use raw ZIP scanning pattern (like WrapContext/NoteContext). `MathContext` struct with `HashMap<usize, Vec<MathEquation>>` keyed by body child index. `build_math_context(data)` opens ZIP, reads `word/document.xml`, calls `omml::scan_math_equations(xml)`. `scan_math_equations()` tracks `depth_in_body` to count top-level body children, processes `m:oMath`/`m:oMathPara` inline via `parse_omml_children()`. IR: `Block::MathEquation(MathEquation { content: String, display: bool })`. Codegen: display → `$ content $\n`, inline → `$content$`. OMML elements handled: `m:f` (fraction→`frac()`), `m:sSup`/`m:sSub`/`m:sSubSup` (scripts→`^`/`_`), `m:rad` (radical→`sqrt()`/`root()`), `m:d` (delimiter→parens), `m:nary` (n-ary→`sum`/`product`/`integral`), `m:func`, `m:limLow`/`m:limUpp`, `m:acc`, `m:bar`, `m:eqArr`. Math run text: `m:r`→`m:t` via `xml_content()`. Test DOCX with math: `build_docx_with_math(document_xml)` creates minimal ZIP with custom `word/document.xml`.
- **DOCX embedded charts**: docx-rs does NOT parse chart drawings — `DrawingData::Pic` handler silently skips charts. Use raw ZIP scanning. `ChartContext` with `HashMap<usize, Vec<Chart>>` keyed by body child index. `build_chart_context(data)` reads `word/_rels/document.xml.rels` for chart relationships (`scan_chart_rels`), scans `word/document.xml` for `<c:chart r:id="...">` in `<a:graphicData uri="...chart">` (`scan_chart_references`), reads each `word/charts/chartN.xml`, and calls `parse_chart_xml()`. IR: `Chart { chart_type: ChartType, title: Option<String>, categories: Vec<String>, series: Vec<ChartSeries> }`, `ChartSeries { name: Option<String>, values: Vec<f64> }`. Chart types: `barChart`→Bar, `barChart barDir=col`→Column (but currently just Bar), `lineChart`→Line, `pieChart`→Pie, `areaChart`→Area, `scatterChart`→Scatter. Data from `<c:strCache>/<c:numCache>` within `<c:ser>`. Codegen: title as bold centered text, type label as italic, data table with `#table(columns: N, ...)`. Test DOCX with chart: `build_docx_with_chart()` creates ZIP with `[Content_Types].xml`, `_rels/.rels`, `word/_rels/document.xml.rels` (chart relationship), `word/document.xml` (with `<c:chart r:id>`), `word/charts/chart1.xml` (barChart with data).
- **PPTX SmartArt diagrams**: SmartArt uses `<p:graphicFrame>` with `<a:graphicData uri="...diagram">` containing `<dgm:relIds r:dm="rIdN" .../>`. Detection via `smartart::scan_smartart_refs(slide_xml)` → `Vec<SmartArtRef>` (position + data_rid). Data resolved by `load_smartart_data(slide_path, archive)` which reads slide .rels for targets containing "diagrams/data", then parses each data XML via `smartart::parse_smartart_data_xml()`. Data model XML (`ppt/diagrams/dataN.xml`): `<dgm:ptLst>` contains `<dgm:pt modelId type>` elements. Only `type="node"` (or absent type, which defaults to "node") have user content; skip `type="doc"`, `type="parTrans"`, `type="sibTrans"`. Text in `<dgm:t>/<a:p>/<a:r>/<a:t>`. IR: `SmartArt { items: Vec<String> }`, `FixedElementKind::SmartArt`. Codegen: bordered `#block` with "SmartArt Diagram" header and `- item` list. Integration point: `parse_single_slide()` (not `parse_slide_xml()`) since SmartArt requires ZIP archive access. Test helper: `build_test_pptx_with_smartart(cx, cy, slide_xml, data_rid, data_xml)`, `make_smartart_graphic_frame(x, y, cx, cy, dm_rid)`, `make_smartart_data_xml(&["Item 1", "Item 2"])`.
- **PPTX embedded charts**: Charts in PPTX use `<p:graphicFrame>` with `<a:graphicData uri="...chart">` containing `<c:chart r:id="rIdN"/>`. Detection via `chart::scan_pptx_chart_refs(slide_xml)` → `Vec<PptxChartRef>` (position in EMU + chart_rid). Chart data resolved by `load_chart_data(slide_path, archive)` which reads slide .rels for targets containing "chart", then reads chart XML from ZIP and parses via `chart::parse_chart_xml()`. Returns `ChartMap` (HashMap<String, Chart>). Chart XML is the same format as DOCX charts — `parse_chart_xml()` is fully reusable. IR: `FixedElementKind::Chart(Chart)`. Codegen delegates to existing `generate_chart()`. Integration in `parse_single_slide()` after SmartArt block. Test helpers: `build_test_pptx_with_chart(cx, cy, slide_xml, chart_rid, chart_xml)`, `make_chart_graphic_frame(x, y, cx, cy, chart_rid)`, `make_chart_xml(title, chart_type, categories, series_name, values)`.
- **DOCX floating images**: `WrapContext` scans raw document.xml for `wp:anchor` elements in document order (similar pattern to `NoteContext`). `AnchorWrapInfo` stores wrap_mode (WrapMode) and behind_doc (bool). `scan_anchor_wrap_types()` parses wp:wrapSquare→Square, wp:wrapTight/wrapThrough→Tight, wp:wrapTopAndBottom→TopAndBottom, wp:wrapNone→depends on behindDoc. `extract_drawing_image()` checks `pic.position_type == Anchor` → consumes next wrap info → `Block::FloatingImage(FloatingImage)`. Position from `DrawingPosition::Offset(emu)` → `emu / 12700.0` points. Codegen: Square/Tight → `#place(float: true)`, TopAndBottom → `#block` with `#v()` spacer, Behind/InFront/None → `#place()` absolute. Test helpers: `patch_docx_wrap_type(data, old_wrap, new_wrap)` replaces wrap elements in ZIP, `patch_docx_behind_doc(data)` sets `behindDoc="1"`. Create floating test Pic: `Pic::new(&bmp).floating().offset_x(emu).offset_y(emu)` (default: wrapSquare if !allow_overlap), `.overlapping()` → wrapNone.
---

# Ralph Progress Log - Phase 4: P3 Features - Charts, Equations, SmartArt, Polish
Started: 2026년  2월 27일 금요일 12시 19분 03초 KST
---

## 2026-02-27 - US-040: DOCX parser - text wrapping around images
- What was implemented:
  - IR: WrapMode enum (Square, Tight, TopAndBottom, Behind, InFront, None) and FloatingImage struct
  - Parser: WrapContext scans raw DOCX XML for wp:anchor wrap elements (wrapSquare, wrapTight, wrapTopAndBottom, wrapNone, wrapThrough) and behindDoc attribute
  - Parser: extract_drawing_image() detects Anchor position_type from docx-rs Pic and produces Block::FloatingImage with position offsets
  - Codegen: generate_floating_image() handles each wrap mode: #place(float:true) for Square/Tight, #block with #v() for TopAndBottom, #place() for Behind/InFront/None
  - Tests: 5 parser tests (square, topAndBottom, behind, position offset, inline-not-floating) + 3 codegen tests
- Files changed:
  - crates/office2pdf/src/ir/elements.rs (WrapMode, FloatingImage, Block::FloatingImage)
  - crates/office2pdf/src/parser/docx.rs (WrapContext, scan_anchor_wrap_types, modified extract_drawing_image)
  - crates/office2pdf/src/render/typst_gen.rs (generate_floating_image, Block::FloatingImage handling)
- Dependencies added: none
- **Learnings for future iterations:**
  - docx-rs parses Pic.position_type (Anchor vs Inline) and position offsets but does NOT parse wrap type elements — need raw ZIP XML scanning (same pattern as NoteContext for footnotes)
  - docx-rs builder writes behindDoc="0" in anchor XML, so test patching must replace the existing attribute value rather than adding a new attribute
  - DrawingPosition::Offset values are in EMU (signed i32); convert via /12700.0 for points
  - Typst 0.14 has no native text wrapping around images — #place(float:true) only supports top/bottom float, not side-by-side wrapping. Best-effort approach is sufficient per acceptance criteria
  - Pre-existing test failure: test_batch_convert_partial_failure in CLI crate (unrelated to this change)
---

## 2026-02-27 - US-041: DOCX parser - OMML math equations
- What was implemented:
  - IR: Block::MathEquation(MathEquation { content: String, display: bool })
  - Parser: omml.rs module — complete OMML→Typst converter (fractions, superscripts, subscripts, radicals, delimiters, n-ary operators, functions, limits, accents, bars, matrices, equation arrays)
  - Parser: MathContext with raw ZIP XML scanning (docx-rs has zero OMML support)
  - Codegen: display math → `$ content $\n`, inline math → `$content$`
  - Tests: 13 unit tests for OMML conversion, 3 DOCX integration tests, 3 codegen tests
- Files changed:
  - crates/office2pdf/src/parser/omml.rs (new)
  - crates/office2pdf/src/parser/mod.rs (module declaration)
  - crates/office2pdf/src/parser/docx.rs (MathContext, build_math_context)
  - crates/office2pdf/src/ir/elements.rs (MathEquation, Block::MathEquation)
  - crates/office2pdf/src/render/typst_gen.rs (generate_math_equation)
---

## 2026-02-27 - US-042: DOCX parser - embedded charts (basic)
- What was implemented:
  - IR: Chart, ChartType (Bar/Column/Line/Pie/Area/Scatter/Other), ChartSeries, Block::Chart
  - Parser: chart.rs module — parses chart*.xml files from DOCX ZIP, extracts chart type, title, categories, series data from cached values (strCache/numCache)
  - Parser: scan_chart_references() scans document.xml for c:chart elements in graphicData URIs
  - Parser: scan_chart_rels() extracts chart relationship mappings from document.xml.rels
  - Parser: ChartContext integration in docx.rs with build_chart_context()
  - Codegen: renders charts as data tables — title (bold centered), chart type label (italic centered), #table() with category + series columns
  - Tests: 4 chart parser unit tests, 2 scan tests, 3 codegen tests
- Files changed:
  - crates/office2pdf/src/parser/chart.rs (new)
  - crates/office2pdf/src/parser/mod.rs (module declaration)
  - crates/office2pdf/src/parser/docx.rs (ChartContext, build_chart_context)
  - crates/office2pdf/src/ir/elements.rs (Chart, ChartType, ChartSeries, Block::Chart)
  - crates/office2pdf/src/render/typst_gen.rs (generate_chart, ChartSeries import)
- **Learnings for future iterations:**
  - docx-rs does not parse chart drawing elements — charts silently skipped in DrawingData::Pic handler
  - Chart data is in cached values (<c:strCache>/<c:numCache>) inside <c:ser> elements, avoiding need to parse external embedded XLSX workbooks
  - Charts referenced via r:id in <c:chart> element within <a:graphicData uri="...chart">
  - Relationship targets are relative to word/ directory
  - barDir val="bar" means horizontal bars, val="col" means vertical columns
---

## 2026-02-27 - US-043: PPTX parser - SmartArt diagrams (basic)
- What was implemented:
  - IR: SmartArt struct (items: Vec<String>), FixedElementKind::SmartArt variant
  - Parser: smartart.rs module — parse_smartart_data_xml() extracts text from dgm:pt type="node" elements in diagram data model XML, scan_smartart_refs() detects SmartArt graphicFrames and extracts dgm:relIds r:dm relationship IDs
  - Integration: parse_single_slide() scans slide XML for SmartArt references, resolves data files via slide .rels (targets containing "diagrams/data"), adds FixedElementKind::SmartArt elements at graphicFrame position
  - Codegen: generate_smartart() renders as bordered box with "SmartArt Diagram" header and Typst bulleted list (- item) format
  - Tests: 8 unit tests (data parsing including type filtering, multi-run text, ref scanning), 3 PPTX integration tests (SmartArt produces elements, mixed with text box, no SmartArt slide), 3 codegen tests (basic, empty, special chars escaping)
- Files changed:
  - crates/office2pdf/src/parser/smartart.rs (new — parse_smartart_data_xml, scan_smartart_refs, SmartArtRef)
  - crates/office2pdf/src/parser/mod.rs (module declaration)
  - crates/office2pdf/src/parser/pptx.rs (SmartArtMap, load_smartart_data, integration in parse_single_slide, test helpers and tests)
  - crates/office2pdf/src/ir/elements.rs (SmartArt struct)
  - crates/office2pdf/src/ir/document.rs (FixedElementKind::SmartArt variant)
  - crates/office2pdf/src/render/typst_gen.rs (generate_smartart, SmartArt codegen tests)
- Dependencies added: none
- **Learnings for future iterations:**
  - SmartArt in PPTX uses dgm:relIds inside graphicFrame's graphicData (URI contains "diagram")
  - SmartArt data model XML has dgm:pt elements with type attribute: "doc" (root), "node" (content), "parTrans"/"sibTrans" (transitions) — only "node" types contain user content
  - Points without explicit type attribute default to "node"
  - Text is nested deeply: dgm:pt → dgm:t → a:p → a:r → a:t — careful match arm ordering needed to avoid matching nested a:t as dgm:t
  - SmartArt data files are referenced in slide .rels with targets like "../diagrams/data1.xml"
  - Detection handled outside parse_slide_xml (in parse_single_slide) since SmartArt requires ZIP archive access for data files, keeping parse_slide_xml focused on XML-only parsing
---

## 2026-02-27 - US-044: PPTX parser - embedded charts (basic)
- What was implemented:
  - IR: FixedElementKind::Chart(Chart) variant added to support charts on fixed-layout (PPTX) pages
  - Parser: scan_pptx_chart_refs() in chart.rs — scans slide XML for graphicFrame elements containing chart URI in graphicData, extracts position/size and r:id
  - Parser: PptxChartRef struct holds position (EMU) and chart_rid
  - Parser: load_chart_data() in pptx.rs — scans slide .rels for chart relationships, reads chart XML from ZIP, parses via existing parse_chart_xml()
  - Integration: parse_single_slide() now scans for chart refs after SmartArt, adds FixedElementKind::Chart elements at graphicFrame position
  - Codegen: FixedElementKind::Chart handled in generate_fixed_element(), delegates to existing generate_chart() which renders as data table
  - Tests: 3 scanner tests (basic, no chart, multiple), 3 PPTX integration tests (chart produces element, chart + text box, no chart), 3 codegen tests (basic, no title, empty series)
- Files changed:
  - crates/office2pdf/src/ir/document.rs (FixedElementKind::Chart variant)
  - crates/office2pdf/src/parser/chart.rs (PptxChartRef struct, scan_pptx_chart_refs function, 3 tests)
  - crates/office2pdf/src/parser/pptx.rs (Chart import, chart module import, ChartMap type, load_chart_data function, parse_single_slide integration, test helpers + 3 tests)
  - crates/office2pdf/src/render/typst_gen.rs (FixedElementKind::Chart codegen, 3 codegen tests)
- Dependencies added: none
- **Learnings for future iterations:**
  - PPTX charts use same chart XML format as DOCX charts — parse_chart_xml() is fully reusable
  - Charts in PPTX are in graphicFrame elements with graphicData URI containing "chart" and <c:chart r:id="rIdN"/> child element
  - Chart files referenced in slide .rels with targets like "../charts/chart1.xml"
  - Pattern mirrors SmartArt exactly: scan refs → load data → add FixedElements in parse_single_slide()
  - The load_chart_data function filters .rels targets by "chart" substring — same approach as SmartArt filtering by "diagrams/data"
---

## 2026-02-27 - US-045: XLSX parser - conditional formatting (basic)
- What was implemented:
  - New module: cond_fmt.rs — conditional formatting rule evaluation and override building
  - CellIs rules: evaluate_cell_is_rule() supports GreaterThan, LessThan, Equal, Between operators
  - Formatting extraction: extract_cond_fmt_style() extracts background color, font color, bold from rule styles
  - Color scale: 2-color and 3-color gradient interpolation via interpolate_color()
  - Integration: build_cond_fmt_overrides() builds HashMap<(col,row), CondFmtOverride> from sheet's conditional formatting collection
  - Override application: xlsx.rs parse loop applies overrides to cell text_style and background after normal style extraction
  - Tests: 5 unit tests in cond_fmt.rs (sqref parsing, color interpolation), 7 integration tests in xlsx.rs (greater than bg, less than font color, equal bold, between, color scale 2-color, no rules unchanged, non-numeric skipped)
- Files changed:
  - crates/office2pdf/src/parser/cond_fmt.rs (new — CondFmtOverride, build_cond_fmt_overrides, evaluate_cell_is_rule, extract_cond_fmt_style, interpolate_color, parse_sqref, color scale logic)
  - crates/office2pdf/src/parser/mod.rs (module declaration)
  - crates/office2pdf/src/parser/xlsx.rs (import + call build_cond_fmt_overrides, apply overrides in cell loop, 7 integration tests)
- Dependencies added: none
- **Learnings for future iterations:**
  - umya-spreadsheet ConditionalFormattingRule only stores ONE formula (OOXML Between uses two <formula> elements but library keeps only last). Best-effort: Between = >=threshold
  - Formula value accessed via `formula.get_address_str()` (NOT `get_value()` which doesn't exist)
  - sheet.get_conditional_formatting_collection() returns &[ConditionalFormatting], each with SequenceOfReferences (sqref) and ConditionalFormattingRule collection
  - Rule style accessed via rule.get_style() → Option<&Style>, same Style struct as cell formatting (get_background_color, get_font, etc.)
  - ColorScale has cfvo_collection (min/max type markers) and color_collection (ARGB colors). Use parse_umya_color_argb() for conversion
  - Color interpolation for 3-color scales splits at ratio 0.5: [min→mid] for lower half, [mid→max] for upper half
---

## 2026-02-27 - US-046: XLSX parser - embedded charts (basic)
- What was implemented:
  - extract_charts_from_zip(data) scans xl/charts/chart*.xml entries in XLSX ZIP archive
  - Parses each chart XML via shared chart::parse_chart_xml() (supports bar, line, pie, area, scatter)
  - Charts rendered as Page::Flow(FlowPage) with Block::Chart(chart) — each chart gets its own page
  - Reuses shared chart parsing and Typst codegen (data table rendering) from DOCX/PPTX chart support
  - Tests: 3 integration tests (chart produces page, no chart = no extra pages, chart data correctness with pie chart)
- Files changed:
  - crates/office2pdf/src/parser/xlsx.rs (extract_charts_from_zip function, parse() integration, 3 tests)
- Dependencies added: none
- **Learnings for future iterations:**
  - XLSX charts stored at xl/charts/chart*.xml in ZIP (same OpenXML chart format as DOCX/PPTX)
  - No drawing relationship scanning needed — simply enumerate ZIP entries matching the prefix
  - Charts added after all TablePages as separate FlowPages
  - Test helper: build_xlsx_with_chart() creates valid XLSX then re-opens ZIP to inject chart XML entry
---

## 2026-02-27 - US-047: Performance optimization
- What was implemented:
  - Criterion benchmark suite: benches/conversion.rs with DOCX (10/100 pages), PPTX (10/100 slides), XLSX (50/500 rows) benchmarks
  - Pre-allocation optimizations:
    - typst_gen.rs: String::with_capacity(pages * 2048) for output buffer, Vec::with_capacity(4) for border parts
    - xlsx.rs: Vec::with_capacity(num_rows/num_cols) for table rows and cells
    - pptx.rs: Vec::with_capacity(slide_rids.len()) for pages
- Benchmark results (MacOS, Apple Silicon):
  - DOCX 10 pages (~30 paragraphs): 124ms — target <1s PASS
  - DOCX 100 pages (~300 paragraphs): 130ms — target <5s PASS
  - PPTX 10 slides: 120ms — target <1s PASS
  - PPTX 100 slides: 124ms — target <5s PASS
  - XLSX 50 rows (5 cols): 125ms
  - XLSX 500 rows (5 cols): 136ms
  - Pipeline dominated by Typst initialization (~120ms baseline), parsing/codegen is <15ms for 100-page documents
- Files changed:
  - crates/office2pdf/Cargo.toml (criterion dev-dep, bench target)
  - crates/office2pdf/benches/conversion.rs (new — benchmark suite)
  - crates/office2pdf/src/render/typst_gen.rs (pre-allocation optimizations)
  - crates/office2pdf/src/parser/xlsx.rs (Vec::with_capacity for rows/cells)
  - crates/office2pdf/src/parser/pptx.rs (Vec::with_capacity for pages)
- Dependencies added: criterion 0.5 (dev-dependency)
---

## 2026-02-27 - US-048: Edge case handling and robustness
- What was implemented:
  - 13 edge case tests covering all acceptance criteria
  - Empty documents: DOCX, XLSX, PPTX with no content all produce valid PDFs
  - Long content: 10,000-char paragraph and 100x20 table (2000 cells) convert without panic
  - Corrupted/truncated files: corrupted DOCX/XLSX/PPTX and truncated ZIP all return clear errors
  - Unicode: CJK text (Chinese, Japanese, Korean), emoji, RTL text (Arabic) all produce valid PDFs
  - Image-only documents: DOCX with only image blocks (no text) converts successfully
  - Performance optimization: image data in pdf.rs World uses Bytes (ref-counted) instead of Vec<u8> clone
- Files changed:
  - crates/office2pdf/src/lib.rs (13 new edge case tests)
  - crates/office2pdf/src/render/pdf.rs (Bytes optimization for image data)
  - scripts/ralph/prd.json (US-048 passes: true)
- Dependencies added: none
---
