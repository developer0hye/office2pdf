## Codebase Patterns
- **XLSX cell formatting**: `cell.get_style()` → `&Style`. Font: `style.get_font()` → `Option<&Font>` with `get_name()`, `get_size()`, `get_bold()`, `get_italic()`, `get_underline()`, `get_strikethrough()`, `get_color().get_argb()`. Background: `style.get_background_color()` → `Option<&Color>` with `get_argb()` (ARGB 8-char hex, skip first 2 for alpha). Borders: `style.get_borders()` → `Option<&Borders>` with `get_top/bottom/left/right()` → `&Border` with `get_border_style()` (str) and `get_color().get_argb()`. Border widths: hair=0.25pt, thin=0.5pt, medium=1.0pt, thick=2.0pt. Row height: `sheet.get_row_dimension(&row_idx)` → `Option<&Row>` with `get_height()` and `get_custom_height()`. Test setup: `cell.get_style_mut().get_font_mut().set_bold(true)`, `style.set_background_color("FFFFFF00")`, `style.get_borders_mut().get_bottom_mut().set_border_style("medium")`, `sheet.get_row_dimension_mut(&1).set_height(30.0)`. Defaults to skip: font name "Calibri", size 11.0, color "FF000000".
- **XLSX number formats**: Use `cell.get_formatted_value()` instead of `cell.get_value().to_string()` to get pre-formatted cell text. umya-spreadsheet handles all formatting internally: currency ($#,##0.00), percentage (0%), dates (yyyy-mm-dd), thousands separators (#,##0), custom format strings. Set format: `cell.get_style_mut().get_number_format_mut().set_format_code("format")` or `.set_number_format_id(id)`. Built-in format IDs: 0=General, 1=0, 2=0.00, 3=#,##0, 4=#,##0.00, 9=0%, 10=0.00%, 14=m/d/yyyy. For dates: use `set_value_number(serial)` where serial is Excel date serial (days since 1900-01-01). "General" format passes through simple numbers unchanged. Constants: `NumberingFormat::FORMAT_CURRENCY_USD_SIMPLE`, `FORMAT_PERCENTAGE`, `FORMAT_DATE_YYYYMMDD`, etc.
- **DOCX document styles**: `docx.styles.styles` is `Vec<Style>` with `style_id`, `name`, `style_type`, `run_property`, `paragraph_property`. Access via `docx.styles`. `ParagraphProperty.style: Option<ParagraphStyle>` stores the pStyle reference; `ParagraphStyle.val` is the style ID string. `Style.paragraph_property.outline_lvl: Option<OutlineLvl>` with `OutlineLvl.v: usize` (public) for heading level detection (0=H1..5=H6). `Name.name` is private — use `serde_json::to_value(&name)` → string. Create test styles: `Style::new("Heading1", StyleType::Paragraph).name("Heading 1").outline_lvl(0).bold().size(48)`. Apply to paragraph: `Paragraph::new().style("Heading1")`. The `build_style_map()` function builds `StyleMap` (HashMap<String, ResolvedStyle>) from docx styles. `merge_text_style()` and `merge_paragraph_style()` merge style defaults with explicit formatting (explicit wins). Heading defaults (when style doesn't specify): H1=24pt, H2=20pt, H3=16pt, H4=14pt, H5=12pt, H6=11pt, all bold.
- **Typst compilation**: Use `MinimalWorld` struct implementing `World` trait. `FontSearcher::new().include_system_fonts(true).search()` discovers system fonts with embedded fallbacks (Libertinus Serif, New Computer Modern, DejaVu Sans Mono via `embed-fonts` feature). Create `Source` with `FileId::new(None, VirtualPath::new("main.typ"))`.
- **DOCX list detection**: Check `para.has_numbering` and `para.property.numbering_property` for `NumberingProperty { id: Option<NumberingId>, level: Option<IndentLevel> }`. `NumberingId.id` is the numId, `IndentLevel.val` is the ilvl (0-based). numId=0 means "no numbering". Resolve numId → abstractNumId via `docx.numberings.numberings`, then check `abstract_num.levels[0].format` (use serde) for `"bullet"` (Unordered) vs `"decimal"`/etc. (Ordered). Group consecutive list paragraphs with same numId into `Block::List`.
- **Typst list codegen**: Use `#list(list.item[content], ...)` for unordered, `#enum(enum.item[content], ...)` for ordered. Nested items: emit a sub-list `[#list(...)]` after the parent item. The `generate_list_items()` function recursively handles nesting based on item levels.
- **docx-rs test list creation**: `docx_rs::Paragraph::new().add_run(...).numbering(NumberingId::new(1), IndentLevel::new(0))`. Need `AbstractNumbering::new(id).add_level(Level::new(level, Start::new(1), NumberFormat::new("bullet"|"decimal"), LevelText::new("•"|"%1."), LevelJc::new("left")))` and `Numbering::new(numId, abstractNumId)`, wrapped in `Numberings::new().add_abstract_numbering(an).add_numbering(n)` and set via `Docx::new().numberings(nums)`.
- **Typst codegen structure**: Each FlowPage emits `#set page(...)` then paragraphs. Text runs use `#text(props)[content]` for styling. Underline/strikethrough wrap with `#underline[...]`/`#strike[...]`. Special chars (`#`, `*`, `_`, `$`, etc.) must be escaped with `\`.
- **IR module imports**: Style types (Alignment, Color, TextStyle, ParagraphStyle, LineSpacing) are re-exported via `crate::ir::*` — do NOT import from `crate::ir::style::` (private module).
- **Quality gates**: Always run `cargo fmt --all -- --check`, `cargo clippy --workspace -- -D warnings`, `cargo test --workspace`, `cargo check --workspace` before committing. Use `writeln!` not `write!(...\n)` per clippy.
- **f64 formatting**: Use helper `format_f64()` to strip unnecessary trailing zeros (e.g., `72` not `72.0`).
- **Pipeline testing**: Use `office2pdf::render_document(&doc)` to test IR → PDF without needing parsers. Construct `Document` with mock `FlowPage`/`FixedPage`/`TablePage` data.
- **DOCX headers/footers**: Access via `docx.document.section_property.header` (and `.footer`) — `Option<(String, Header)>`. `Header.children` contains `HeaderChild::Paragraph(Box<Paragraph>)`. Similarly for `Footer`. Use `Docx::new().header(header).footer(footer)` to create test docs.
- **DOCX field codes round-trip**: When docx-rs builds and then reads back, `InstrText::PAGE` becomes `RunChild::InstrTextString("PAGE")` (not `RunChild::InstrText`). Always check both `InstrText` and `InstrTextString` variants.
- **FieldChar direct access**: `FieldChar.field_char_type` is public (`docx_rs::FieldCharType::{Begin,Separate,End}`). No need for serde — access directly.
- **Typst context for counters**: `#counter(page).display()` requires a `context` expression in Typst 0.14. Emit `context [...]` when header/footer contains page numbers.
- **FlowPage header/footer**: `FlowPage` has `header: Option<HeaderFooter>` and `footer: Option<HeaderFooter>`. Set to `None` for no header/footer. `HeaderFooter { paragraphs: Vec<HeaderFooterParagraph> }` with `HFInline::Run(Run)` for text and `HFInline::PageNumber` for page number fields.
- **Typst table codegen**: Use `#table(columns: (Wpt, ...), ...)` with cells as `[content]` (simple) or `table.cell(props)[content]` (when colspan/rowspan/fill/stroke needed). Cell content uses `generate_run()` directly (no block wrapper). Borders: `stroke: (top: 1pt + rgb(r, g, b), ...)`. Background: `fill: rgb(r, g, b)`. Merging: `colspan: N`, `rowspan: N`.
- **docx-rs reading**: `docx_rs::read_docx(&[u8])` → `Docx`. Access `docx.document.children` (Vec<DocumentChild>). Paragraphs: `DocumentChild::Paragraph(Box<Paragraph>)`. Runs: `ParagraphChild::Run(Box<Run>)`. Text: `RunChild::Text(Text)` → `t.text`. Tab: `RunChild::Tab`. Break: `RunChild::Break`.
- **docx-rs private fields**: `PageSize` (w, h), `Bold` (val), `Italic` (val), `Sz` (val), `Color` (val), `Underline` (val), `RunFonts` (ascii, hi_ansi, etc.) all have private fields. Use `serde_json::to_value()` to extract values since they implement Serialize. **IMPORTANT**: These types serialize as their *direct inner value* (e.g. `Bold` → `true`, `Sz` → `24`, `Color` → `"FF0000"`), NOT as `{"val": ...}`. Use `json.as_bool()`, `json.as_f64()`, `json.as_str()` directly. `RunFonts` serializes as an object with `ascii`, `hi_ansi`, etc. fields. `Strike` has `pub val: bool` — accessible directly without serde.
- **DOCX units**: Page size and margins in OOXML are in twips (1 twip = 1/20 pt). Convert: `value_twips / 20.0 = points`. PageMargin fields are public i32. docx-rs default page size: 11906 x 16838 twips (A4).
- **DOCX page orientation**: `extract_page_size()` reads orient via `serde_json::to_value(&page_size).get("orient")`. If orient is `"landscape"` and width < height, dimensions are swapped. Note: docx-rs reader does NOT populate orient from XML — only the builder does. Real DOCX files already have swapped w/h for landscape. For test creation: `Docx::new().page_size(16838, 11906).page_orient(docx_rs::PageOrientationType::Landscape)`.
- **Test DOCX creation**: Use `docx_rs::Docx::new().add_paragraph(...)`, then `.build().pack(&mut Cursor::new(Vec::new()))` to get bytes. Use `Cursor::into_inner()` to extract.
- **Typst FixedPage codegen**: Slides use `#set page(width: Wpt, height: Hpt, margin: 0pt)`. Elements use `#place(top + left, dx: Xpt, dy: Ypt)[...]` for absolute positioning. TextBox wraps content in `#block(width: Wpt, height: Hpt)[...]`. Shapes: `#rect(width, height, fill?, stroke?)`, `#ellipse(...)`, `#line(start, end, stroke?)`. Images use existing `generate_image()` inside place.
- **umya-spreadsheet merge API**: `sheet.get_merge_cells()` → `&[Range]`. Range has `get_coordinate_start_col/row()` and `get_coordinate_end_col/row()` → `Option<&ColumnReference/RowReference>`. Use `*ref.get_num()` for 1-indexed u32 coordinate. `sheet.add_merge_cells("A1:C5")` for test creation. Must expand `get_highest_column_and_row()` grid to include merge extents since that method only considers cells with data.
- **umya-spreadsheet reading**: `umya_spreadsheet::reader::xlsx::read_reader(Cursor::new(data), true)` → `Spreadsheet`. Sheets: `book.get_sheet_collection()`. Sheet name: `sheet.get_name()`. Cell: `sheet.get_cell((col, row))` → **IMPORTANT: tuple is (column, row), NOT (row, column)**. Cell value: `cell.get_value().to_string()`. Dimensions: `sheet.get_highest_column_and_row()` → `(max_col, max_row)`. Column width: `sheet.get_column_dimension_by_number(&col)` → `Option<&Column>`, then `col.get_width()` (Excel char units, ×7.0 → points).
- **Test XLSX creation**: `umya_spreadsheet::new_file()` → `Spreadsheet`. Set cell: `sheet.get_cell_mut("A1").set_value("text")`. Write: `umya_spreadsheet::writer::xlsx::write_writer(&book, &mut Cursor::new(Vec::new()))`. Multi-sheet: first sheet via `book.get_sheet_mut(&0)`, additional via `book.add_sheet(Worksheet::default())`.
- **Typst TablePage codegen**: `generate_table_page()` calls `write_page_setup()` + `generate_table()`. Reuses all existing table infrastructure (cell merging, borders, backgrounds, column widths). TablePage = page setup + a single Table element.
- **PPTX parsing**: Use `zip` + `quick-xml` (both already transitive deps, no new downloads). PPTX is a ZIP: `ppt/presentation.xml` (slide size + slide refs via `<p:sldSz cx cy>` + `<p:sldId r:id>`), `ppt/_rels/presentation.xml.rels` (rId → slide path), `ppt/slides/slideN.xml` (shapes). Parse with `ZipArchive::new(Cursor::new(data))` → `read_zip_entry()` → `quick_xml::Reader::from_str()`.
- **PPTX slide XML structure**: Shapes at `<p:spTree>/<p:sp>`. Position/size: `<a:xfrm><a:off x y/><a:ext cx cy/></a:xfrm>` (EMU ÷ 12700 = points). Text: `<p:txBody>/<a:p>/<a:r>/<a:t>`. Run props: `<a:rPr b="1" i="1" u="sng" strike="sngStrike" sz="1800">` (sz in hundredths of pt). Font color: `<a:solidFill><a:srgbClr val="RRGGBB"/></a:solidFill>`. Font family: `<a:latin typeface="..."/>`. Para alignment: `<a:pPr algn="ctr|l|r|just"/>`.
- **Test PPTX creation**: Build ZIP in-memory with `zip::ZipWriter::new(Cursor::new(Vec::new()))`. Need `[Content_Types].xml`, `_rels/.rels`, `ppt/presentation.xml`, `ppt/_rels/presentation.xml.rels`, and `ppt/slides/slideN.xml`. Standard 4:3 size: 9144000 × 6858000 EMU = 720pt × 540pt.
- **quick-xml 0.38 API**: Use `Reader::from_str(xml)`, `reader.read_event()` → `Event::Start/Empty/End/Text/Eof`. `BytesText::xml_content()` (NOT `unescape()`!) for text decoding. `BytesStart::local_name().as_ref()` for element name. Attributes: iterate `e.attributes().flatten()`, match `attr.key.as_ref()` (full name like `r:id`) or `attr.key.local_name().as_ref()` (local). `attr.unescape_value()` for string values.
- **PPTX shapes**: `<p:sp>` without text body → Shape IR element. Geometry from `<a:prstGeom prst="rect|ellipse|line">`. Fill color: `<p:spPr><a:solidFill><a:srgbClr val="RRGGBB"/></a:solidFill>`. Border: `<a:ln w="12700"><a:solidFill>...</a:solidFill></a:ln>` (w in EMU, ÷12700 → pt). Use `SolidFillCtx` enum to distinguish shape fill vs line fill vs run fill contexts.
- **PPTX images**: `<p:pic>` element. Position/size from `<p:spPr><a:xfrm>`. Image ref: `<a:blip r:embed="rId3"/>`. Resolve rId via slide .rels file (`ppt/slides/_rels/slideN.xml.rels`), then read image bytes from ZIP. Image format detected from file extension.
- **PPTX slide .rels**: Path pattern: `ppt/slides/_rels/slideN.xml.rels`. Image targets are relative paths like `../media/image1.png`. Use `resolve_relative_path()` to compute full ZIP path from slide directory.
- **docx-rs image handling**: Images in document tree: `RunChild::Drawing(Box<Drawing>)` → `Drawing.data = Some(DrawingData::Pic(pic))`. Image binary data: stored in `Docx.images` as `Vec<(id, path, Image, Png)>` — match `pic.id` to look up data. `pic.image` is empty when reading (only used during writing). Dimensions: `pic.size = (w_emu, h_emu)` in EMU. Convert: EMU ÷ 12700 = points. All images converted to PNG by docx-rs.
- **Test images for docx-rs**: Use `make_test_bmp()` to create a minimal 1×1 BMP, then `Pic::new(&bmp_data)` which processes through the `image` crate. Do NOT use `Pic::new_with_dimensions()` with raw PNG bytes for round-trip tests — the `image` crate may fail to decode minimal hand-crafted PNGs during `read_docx()`.
- **Image codegen**: `generate_typst()` returns `TypstOutput { source: String, images: Vec<ImageAsset> }`. Images get virtual paths `img-N.ext` via `GenCtx`. `compile_to_pdf(source, &images)` passes images to `MinimalWorld` which serves them via `World::file()`. Image markup: `#image("img-0.png", width: Wpt, height: Hpt)`.
- **Valid test PNG**: For tests that compile Typst with images, use `make_test_png()` helper which builds a 1x1 PNG with correct CRC32 checksums. For codegen-only tests, any byte slice works since Typst doesn't validate during codegen.
- **Parser trait returns warnings**: `Parser::parse()` returns `Result<(Document, Vec<ConvertWarning>), ConvertError>`. Destructure with `let (doc, _warnings) = parser.parse(&data)?;` in existing tests.
- **ConvertResult**: Public API (`convert`, `convert_bytes`) returns `ConvertResult { pdf: Vec<u8>, warnings: Vec<ConvertWarning> }` instead of bare `Vec<u8>`. Access PDF bytes via `.pdf`.
- **PPTX per-slide error recovery**: Each slide is parsed independently via `parse_single_slide()`. If a slide fails (missing file, broken XML), a warning is emitted and the slide is skipped.
- **DOCX per-element error recovery**: Each `DocumentChild` is processed inside `std::panic::catch_unwind`. If an element panics, a warning is emitted and processing continues.
- **PPTX theme parsing**: `ThemeData` struct holds `colors: HashMap<String, Color>`, `major_font: Option<String>`, `minor_font: Option<String>`. Parsed from `ppt/theme/theme1.xml` via `parse_theme_xml()`. Theme file located via presentation.xml.rels (relationship type containing "theme"). Color scheme elements: `dk1`, `dk2`, `lt1`, `lt2`, `accent1`-`accent6`, `hlink`, `folHlink`. Colors can be `<a:srgbClr val="RRGGBB"/>` or `<a:sysClr lastClr="RRGGBB"/>`. Font scheme: `<a:majorFont><a:latin typeface="..."/>` and `<a:minorFont><a:latin typeface="..."/>`.
- **PPTX scheme color resolution**: In slide XML, `<a:schemeClr val="accent1"/>` resolves to RGB via `theme.colors.get(&scheme_name)`. Handled in both Start and Empty events (schemeClr can have children like `<a:tint/>`). When no theme is loaded, scheme colors resolve to `None`.
- **PPTX theme font resolution**: `<a:latin typeface="+mj-lt"/>` → major font, `<a:latin typeface="+mn-lt"/>` → minor font. `resolve_theme_font()` substitutes these references. Explicit font names pass through unchanged.
- **Test PPTX with theme**: Use `build_test_pptx_with_theme(cx, cy, slides, theme_xml)`. Includes `ppt/theme/theme1.xml` in ZIP and theme relationship in presentation.xml.rels. `make_theme_xml(colors, major_font, minor_font)` creates theme XML. `standard_theme_colors()` returns Office-like defaults.
- **PPTX slide backgrounds**: `FixedPage.background_color: Option<Color>`. Parsed from `<p:bg><p:bgPr><a:solidFill>` in slide XML via `parse_background_color(xml, theme)`. Supports `<a:srgbClr>` and `<a:schemeClr>`. Inheritance chain: slide → layout → master via `resolve_inherited_background()`. Layout path from slide .rels (relationship target containing "slideLayout"), master path from layout .rels (target containing "slideMaster"). Typst codegen: `#set page(..., fill: rgb(r, g, b))` when background_color is Some.
- **Test PPTX with layout/master**: Use `build_test_pptx_with_layout_master(cx, cy, slide_xml, layout_xml, master_xml)`. Creates full inheritance chain: slide1 → slideLayout1 → slideMaster1 with .rels files at each level. `make_slide_xml_with_bg(bg_xml, shapes)` creates slide XML with `<p:bg>` inside `<p:cSld>`.
- **PPTX layout/master element inheritance**: `parse_single_slide()` resolves layout and master paths via `resolve_layout_master_paths()`, then parses elements from master, layout, and slide in order (master behind → layout → slide on top). Uses `rels_path_for()` helper for .rels path construction. `parse_slide_xml()` works on any XML with `<p:spTree>` — same function parses slide, layout, and master shapes. Test helpers: `make_layout_xml(shapes)`, `make_master_xml(shapes)`, `build_test_pptx_with_layout_master_multi_slide(cx, cy, slides, layout, master)` for multi-slide testing.
- **PPTX tables**: Tables live inside `<p:graphicFrame>` elements (not `<p:sp>`). Position from `<p:xfrm>` (not `<a:xfrm>`). Table XML: `<a:graphic><a:graphicData><a:tbl>`. Grid: `<a:tblGrid><a:gridCol w="EMU"/>`. Rows: `<a:tr h="EMU">`. Cells: `<a:tc>` with optional `gridSpan` (colspan), `rowSpan`, `hMerge`/`vMerge` (continuation). Cell content: `<a:txBody>` with same paragraph/run structure as shapes. Cell properties: `<a:tcPr>` with `<a:solidFill>` for background, `<a:lnL/lnR/lnT/lnB w="EMU">` for borders. Maps to `FixedElementKind::Table(Table)` in IR. `parse_pptx_table()` is a standalone sub-parser called from `parse_slide_xml()` when `<a:tbl>` is found. Test helpers: `make_table_graphic_frame(x, y, cx, cy, col_widths_emu, rows_xml)`, `make_table_row(cells_text)`, `table_element(elem)`.
---

# Ralph Progress Log - Phase 2: P1 Features - Formatting, Styles, Font Fallback
Started: 2026년  2월 27일 금요일 00시 55분 34초 KST
---

## 2026-02-27 - US-017: Enhanced error handling - skip unparseable elements
- What was implemented:
  - Added `ConvertWarning { element: String, reason: String }` type to `error.rs`
  - Added `ConvertResult { pdf: Vec<u8>, warnings: Vec<ConvertWarning> }` to `error.rs`
  - Changed `Parser::parse()` trait to return `Result<(Document, Vec<ConvertWarning>), ConvertError>`
  - Updated all 3 parsers (DOCX, PPTX, XLSX) to return warnings tuple
  - DOCX parser: `catch_unwind` around each element in document loop
  - PPTX parser: extracted `parse_single_slide()`, catches per-slide errors as warnings
  - XLSX parser: returns empty warnings (framework ready for future element-level recovery)
  - Updated `convert()`, `convert_bytes()`, `convert_with_options()` to return `ConvertResult`
  - CLI prints warnings to stderr via `eprintln!("Warning: {warning}")`
  - Added tests: ConvertWarning display/clone, ConvertResult fields, broken PPTX slide emits warning, normal DOCX has no warnings
- Files changed:
  - `crates/office2pdf/src/error.rs` — new types
  - `crates/office2pdf/src/parser/mod.rs` — trait signature
  - `crates/office2pdf/src/parser/docx.rs` — catch_unwind + tuple return
  - `crates/office2pdf/src/parser/pptx.rs` — per-slide recovery + tuple return
  - `crates/office2pdf/src/parser/xlsx.rs` — tuple return
  - `crates/office2pdf/src/lib.rs` — ConvertResult threading + new tests
  - `crates/office2pdf-cli/src/main.rs` — warning output
- Dependencies added: none
- **Learnings for future iterations:**
  - The `catch_unwind` approach in DOCX parser is a safety net; real-world DOCX errors are rare since docx-rs handles XML parsing before our code runs
  - PPTX per-slide recovery is more naturally testable since slides are independent ZIP entries
  - quick-xml with broken XML often doesn't error — it just finds no matching elements. Use missing ZIP entries for reliable failure testing.
  - All existing parser tests needed `let (doc, _warnings) =` destructuring — use `replace_all` for bulk updates
---

## 2026-02-27 - US-018: Font fallback - system font discovery
- What was implemented:
  - Enabled `embed-fonts` feature in typst-kit Cargo.toml to bundle Libertinus Serif, New Computer Modern, DejaVu Sans Mono as fallback fonts
  - Changed `FontSearcher::include_system_fonts(false)` → `include_system_fonts(true)` in `MinimalWorld::new()` to discover system-installed fonts
  - Font resolution order: system fonts → embedded fallback fonts (handled automatically by typst-kit FontSearcher priority)
  - Added 6 new tests: embedded fonts available, system fonts enabled, compile with system font name, embedded fonts as fallback, IR with system font, IR with multiple font families
- Files changed:
  - `crates/office2pdf/Cargo.toml` — added `embed-fonts` feature to typst-kit
  - `crates/office2pdf/src/render/pdf.rs` — `include_system_fonts(true)` + 3 new tests
  - `crates/office2pdf/src/lib.rs` — 2 new integration tests for system fonts in IR
  - `scripts/ralph/prd.json` — US-018 passes: true
- Dependencies added: `typst-assets` (transitive, via typst-kit `embed-fonts` feature)
- **Learnings for future iterations:**
  - typst-kit `fonts` feature only provides FontSearcher infrastructure — `embed-fonts` is needed for actual bundled font data
  - Without `embed-fonts`, MinimalWorld has 0 fonts but Typst still compiles (renders empty/fallback glyphs)
  - FontSearcher priority: font dirs (highest) → system fonts → embedded fonts (lowest)
  - System font search may be slow on first call (scans filesystem). Consider caching if perf becomes an issue.
---

## 2026-02-27 - US-019: DOCX parser - lists (numbered, bulleted, multi-level)
- What was implemented:
  - Added `List`, `ListItem`, `ListKind` types to IR (`Block::List` variant)
  - Built numbering definition lookup: `build_num_kind_map()` resolves numId → abstractNumId → format ("bullet" = Unordered, else Ordered)
  - Added `extract_num_info()` to detect numPr on paragraphs (numId + ilvl)
  - Created `TaggedElement` enum to track whether a paragraph is a list item or plain content
  - Added `convert_paragraph_element()` wrapper that checks numbering before delegating to existing `convert_paragraph_blocks()`
  - Implemented `group_into_lists()` to group consecutive list paragraphs with same numId into `Block::List` blocks
  - Typst codegen: `generate_list()` emits `#list()` for unordered, `#enum()` for ordered; `generate_list_items()` handles nesting with sub-lists
  - Added handler in `generate_cell_content()` for lists inside table cells
  - 9 new tests: 4 IR tests (list_item_default, list_unordered, list_ordered, list_nested), 3 codegen tests (bulleted, numbered, nested), 2 integration tests (render_document_with_list, e2e_docx_with_list)
  - 4 parser tests: simple_bulleted, simple_numbered, nested_multi_level, mixed_list_and_paragraphs
- Files changed:
  - `crates/office2pdf/src/ir/elements.rs` — new List/ListItem/ListKind types + Block::List variant + 4 tests
  - `crates/office2pdf/src/parser/docx.rs` — numbering detection, TaggedElement, grouping logic + 4 tests
  - `crates/office2pdf/src/render/typst_gen.rs` — generate_list/generate_list_items + Block::List in match arms + 3 tests
  - `crates/office2pdf/src/lib.rs` — 2 integration tests
- Dependencies added: none
- **Learnings for future iterations:**
  - docx-rs `NumberFormat` has a private `val` field — use `serde_json::to_value(&format)` then `.as_str()` to read it
  - docx-rs `Paragraph.has_numbering` is the quick check; `property.numbering_property` has the details
  - numId=0 in OOXML means "remove numbering" — must be filtered out
  - The `TaggedElement` pattern (tagging blocks with metadata before grouping) is clean for post-processing consecutive elements
  - List paragraphs with page breaks before them are demoted to plain blocks to avoid breaking list grouping
---

## 2026-02-27 - US-020: DOCX parser - headers and footers with page numbers
- What was implemented:
  - Added `HeaderFooter`, `HeaderFooterParagraph`, `HFInline` types to IR (elements.rs)
  - Added `header: Option<HeaderFooter>` and `footer: Option<HeaderFooter>` fields to `FlowPage`
  - Implemented `extract_docx_header()` and `extract_docx_footer()` to parse header/footer content from DOCX section properties
  - Implemented `convert_hf_paragraph()` and `extract_hf_run_elements()` for header/footer paragraph parsing with field code detection
  - Detects PAGE field codes via `FieldChar.field_char_type` (Begin/Separate/End) and `InstrText::PAGE` or `InstrTextString("PAGE")`
  - Typst codegen: `write_flow_page_setup()` emits `header: [...]` and `footer: [...]` in `#set page(...)` when present
  - Page numbers use `context [... #counter(page).display() ...]` to satisfy Typst 0.14's context requirement
  - 14 new tests: 2 IR tests, 5 parser tests (text header, text footer, page number footer, both, none), 4 codegen tests, 3 integration tests (render with header, render with page number footer, e2e DOCX with header+footer)
- Files changed:
  - `crates/office2pdf/src/ir/elements.rs` — new HeaderFooter/HFInline types + 2 tests
  - `crates/office2pdf/src/ir/document.rs` — FlowPage header/footer fields
  - `crates/office2pdf/src/parser/docx.rs` — header/footer extraction + field code parsing + 5 tests
  - `crates/office2pdf/src/render/typst_gen.rs` — write_flow_page_setup, generate_hf_content, hf_has_page_number + 4 tests
  - `crates/office2pdf/src/lib.rs` — 3 integration tests + FlowPage field updates across existing tests
- Dependencies added: none
- **Learnings for future iterations:**
  - docx-rs round-trips `InstrText::PAGE` as `InstrTextString("PAGE")` — always check both RunChild variants
  - `FieldChar.field_char_type` is public — no need for serde serialization to access it
  - Typst 0.14 requires `context` for `counter(page).display()` even inside header/footer parameters
  - The `past_separate` flag is essential: text between `Separate` and `End` field chars is the display value and should be skipped
  - Adding optional fields to FlowPage requires updating all existing construction sites — Python scripting can help with bulk updates
---

## 2026-02-27 - US-021: DOCX parser - page orientation (landscape/portrait)
- What was implemented:
  - Enhanced `extract_page_size()` to parse the `orient` field from docx-rs `PageSize` via serde serialization
  - When orient is "landscape" but width < height, dimensions are swapped to ensure landscape pages have width > height
  - Normal case (dimensions already correct for orientation) continues to work unchanged
  - Default remains portrait when no orient attribute is specified
  - Typst codegen required no changes — already handles arbitrary page dimensions correctly
  - 9 new tests: 4 parser tests (portrait, landscape, default portrait, orient+swapped dimensions), 2 unit tests for `extract_page_size` (orient swaps, no orient keeps), 1 codegen integration test (landscape FlowPage renders), 2 e2e tests (landscape DOCX to PDF)
- Files changed:
  - `crates/office2pdf/src/parser/docx.rs` — orient parsing in `extract_page_size()` + 6 tests
  - `crates/office2pdf/src/lib.rs` — 2 integration tests + 1 e2e test
  - `scripts/ralph/prd.json` — US-021 passes: true
- Dependencies added: none
- **Learnings for future iterations:**
  - docx-rs reader (`read_docx`) does NOT parse the `orient` attribute from `<w:pgSz>` XML — it only reads `w` and `h`. The orient field is always `None` after reading.
  - docx-rs builder (`page_orient()`) DOES set the orient field, and serde serialization includes it. So `serde_json::to_value(&page_size)` can detect orient when set via builder.
  - In practice, Microsoft Word DOCX files have swapped w/h for landscape, so orient is mainly a safety net for malformed documents.
  - `PageOrientationType` is publicly exported from `docx_rs` (via `pub use types::*`). Use `docx_rs::PageOrientationType::Landscape`.
  - The orient field serializes as `"landscape"` or `"portrait"` (camelCase due to `#[serde(rename_all = "camelCase")]`).
---

## 2026-02-27 - US-022: DOCX parser - document styles (Heading 1-6)
- What was implemented:
  - Added `ResolvedStyle` struct and `StyleMap` type for mapping style_id → resolved formatting
  - `build_style_map()` extracts paragraph styles from `docx.styles.styles`, reading `run_property`, `paragraph_property`, and `outline_lvl` for heading detection
  - `merge_text_style()` merges style text formatting with explicit run formatting (explicit wins), applying heading defaults (size + bold) when the style's outline_lvl indicates a heading
  - `merge_paragraph_style()` merges style paragraph formatting with explicit paragraph formatting (explicit wins)
  - `get_paragraph_style_id()` reads the pStyle reference from `ParagraphProperty.style`
  - Heading default sizes: H1=24pt, H2=20pt, H3=16pt, H4=14pt, H5=12pt, H6=11pt — all bold
  - Threaded style_map through `convert_paragraph_element()`, `convert_paragraph_blocks()`, `convert_table()`, `extract_raw_rows()`, `extract_cell_content()` so table cell paragraphs also get style resolution
  - 9 new tests: heading1/2 defaults, heading3-6 defaults (loop), custom style formatting, explicit run override, style alignment, normal style no defaults, mixed heading document, color+font style
- Files changed:
  - `crates/office2pdf/src/parser/docx.rs` — style resolution infrastructure + 9 tests
  - `scripts/ralph/prd.json` — US-022 passes: true
- Dependencies added: none
- **Learnings for future iterations:**
  - `docx_rs::Style` has public `style_id`, `style_type`, `run_property`, `paragraph_property` fields — can be accessed directly
  - `Name.name` is private; use `serde_json::to_value()` to extract the string
  - `OutlineLvl.v` is public (no serde needed); 0=Heading 1, 5=Heading 6
  - `ParagraphStyle.val` (pStyle reference) is public — direct access
  - Style resolution uses the same `extract_run_style()` and `extract_paragraph_style()` for both styles and direct formatting — clean reuse
  - Threading the StyleMap through the full call chain (including table cells) ensures consistent style application throughout the document
---

## 2026-02-27 - US-023: PPTX parser - theme colors and fonts
- What was implemented:
  - Added `ThemeData` struct with `colors: HashMap<String, Color>`, `major_font: Option<String>`, `minor_font: Option<String>`
  - Implemented `parse_theme_xml()` to extract color scheme (12 named colors) and font scheme (major/minor latin fonts) from theme1.xml
  - Added `load_theme()` to find theme file path from presentation.xml.rels and parse it
  - Modified `parse_slide_xml()` to accept `&ThemeData` and resolve scheme colors and theme fonts
  - Added `schemeClr` handling in both Start and Empty events: `<a:schemeClr val="accent1"/>` resolves via `theme.colors` lookup
  - Added `resolve_theme_font()`: `+mj-lt` → major font, `+mn-lt` → minor font, explicit names pass through
  - Supports both `<a:srgbClr>` and `<a:sysClr>` (using `lastClr` attribute) in theme color definitions
  - 12 new tests: 4 unit tests (parse_theme_xml_colors, parse_theme_xml_fonts, parse_theme_xml_sys_clr, parse_theme_xml_empty), 3 unit tests (resolve_theme_font major/minor/explicit), 5 integration tests (scheme_color_in_shape_fill, scheme_color_in_line_stroke, scheme_color_in_text_run, theme_major/minor_font_in_text, combined_colors_and_fonts, no_theme_scheme_color_ignored, scheme_color_as_start_element)
- Files changed:
  - `crates/office2pdf/src/parser/pptx.rs` — ThemeData struct, parse_theme_xml(), load_theme(), resolve_theme_font(), schemeClr handling + 12 tests
  - `scripts/ralph/prd.json` — US-023 passes: true
- Dependencies added: none
- **Learnings for future iterations:**
  - Theme file path found via presentation.xml.rels — look for relationship target containing "theme"
  - `sysClr` in theme XML (dk1, lt1) uses `lastClr` attribute for the actual RGB value, not `val` (which is a system color name like "windowText")
  - `schemeClr` can appear as both Empty and Start elements — Start when it has child transforms like `<a:tint>` or `<a:shade>`
  - Color transforms (tint, shade, lumMod, etc.) are not applied — we use the base theme color as-is. Future improvement.
  - Font typeface `+mj-lt` and `+mn-lt` are OOXML conventions for referencing theme major/minor latin fonts
  - When no theme is present, `ThemeData::default()` is used — scheme colors resolve to None and font references stay as-is
---

## 2026-02-27 - US-024: PPTX parser - slide backgrounds
- What was implemented:
  - Added `background_color: Option<Color>` field to `FixedPage` IR struct
  - Implemented `parse_background_color(xml, theme)` to extract solid fill colors from `<p:bg><p:bgPr><a:solidFill>` in slide/layout/master XML
  - Supports both `<a:srgbClr>` (direct hex) and `<a:schemeClr>` (theme color reference, including Start elements with children)
  - Implemented `resolve_inherited_background()` for layout → master fallback chain: reads slide .rels → finds layout → reads layout .rels → finds master
  - Typst codegen: `generate_fixed_page()` emits `fill: rgb(r, g, b)` in `#set page(...)` when `background_color` is Some
  - 10 new tests: 2 IR tests (background_color Some/None), 6 parser tests (solid color, no background, scheme color, with text content, inherit master, layout overrides master), 2 codegen tests (with/without background)
- Files changed:
  - `crates/office2pdf/src/ir/document.rs` — background_color field + 2 tests
  - `crates/office2pdf/src/parser/pptx.rs` — parse_background_color(), resolve_inherited_background(), build_test_pptx_with_layout_master() helper + 6 tests
  - `crates/office2pdf/src/render/typst_gen.rs` — fill: in generate_fixed_page() + 2 tests
- Dependencies added: none
- **Learnings for future iterations:**
  - PPTX background is in `<p:bg>` inside `<p:cSld>`, which appears before `<p:spTree>` — parse_background_color is a separate pass over the XML
  - The inheritance chain (slide → layout → master) uses .rels files at each level to find the next parent
  - Layout path from slide .rels: target containing "slideLayout". Master path from layout .rels: target containing "slideMaster"
  - `resolve_relative_path()` (existing helper) correctly handles "../" in .rels targets (e.g., "../slideLayouts/slideLayout1.xml")
  - The `build_test_pptx_with_layout_master()` test helper creates a full PPTX with .rels at slide, layout, and master levels
---

## 2026-02-27 - US-025: PPTX parser - slide master and layout inheritance
- What was implemented:
  - Extracted `rels_path_for()` helper for building .rels paths from file paths
  - Extracted `resolve_layout_master_paths()` to find layout and master ZIP paths from a slide's .rels chain
  - Refactored `resolve_inherited_background()` to use the new path resolution function
  - Modified `parse_single_slide()` to parse elements from master, layout, and slide in order — master elements appear first (behind), then layout, then slide elements (on top)
  - Layout/master images are also loaded via `load_slide_images()` for each level
  - 5 new tests: master shape on slide, layout shape on slide, element ordering (master→layout→slide), master elements on all slides (multi-slide), slide without layout/master
  - Added test helpers: `make_layout_xml(shapes)`, `make_master_xml(shapes)`, `build_test_pptx_with_layout_master_multi_slide()`
- Files changed:
  - `crates/office2pdf/src/parser/pptx.rs` — `rels_path_for()`, `resolve_layout_master_paths()`, refactored `resolve_inherited_background()`, modified `parse_single_slide()`, 5 tests + 3 helpers
  - `scripts/ralph/prd.json` — US-025 passes: true
- Dependencies added: none
- **Learnings for future iterations:**
  - `parse_slide_xml()` works on any XML with `<p:spTree>` — it doesn't care about the root element (sld, sldLayout, sldMaster), so it reuses cleanly for all three
  - The .rels path pattern is consistent: `{dir}/_rels/{filename}.rels` — extracted into `rels_path_for()` for reuse
  - `resolve_layout_master_paths()` replaces the duplicated path resolution logic that was in `resolve_inherited_background()`
  - Element ordering matters: master elements first, layout second, slide last — this ensures correct visual layering
  - Layout/master can also have images via their own .rels, so `load_slide_images()` is called for each level
---

## 2026-02-27 - US-026: PPTX parser - tables in slides
- What was implemented:
  - Added `FixedElementKind::Table(Table)` variant to IR for tables positioned on fixed pages
  - Implemented `parse_pptx_table()` function to parse `<a:tbl>` elements from PPTX slide XML
  - Handles `<a:tblGrid>` for column widths (EMU → points conversion)
  - Handles `<a:tr>` rows with height and `<a:tc>` cells with text content
  - Cell text parsing: reuses existing `extract_rpr_attributes()` and `extract_paragraph_props()` for formatting (bold, italic, font size, color, font family)
  - Cell merging: `gridSpan` for horizontal merge, `rowSpan` for vertical merge, `hMerge`/`vMerge` for continuation cells (col_span=0 / row_span=0)
  - Cell background: `<a:solidFill>` inside `<a:tcPr>` with srgbClr and schemeClr support
  - Cell borders: `<a:lnL>`, `<a:lnR>`, `<a:lnT>`, `<a:lnB>` inside `<a:tcPr>` with width (EMU) and color
  - Added `<p:graphicFrame>` detection in `parse_slide_xml()` with position tracking via `<p:xfrm>`
  - Typst codegen: `generate_fixed_element()` handles `FixedElementKind::Table` by calling existing `generate_table()` inside `#place()`
  - 8 new tests: basic table, merged cells (gridSpan), vertical merge (rowSpan/vMerge), formatted text, cell background, cell borders, table coexisting with shapes, codegen for table on fixed page
- Files changed:
  - `crates/office2pdf/src/ir/document.rs` — added `FixedElementKind::Table` variant
  - `crates/office2pdf/src/parser/pptx.rs` — `parse_pptx_table()`, graphicFrame handling in `parse_slide_xml()` + 7 tests + 3 helpers
  - `crates/office2pdf/src/render/typst_gen.rs` — Table case in `generate_fixed_element()` + 1 codegen test
  - `scripts/ralph/prd.json` — US-026 passes: true
- Dependencies added: none
- **Learnings for future iterations:**
  - PPTX tables live inside `<p:graphicFrame>` elements, not `<p:sp>` — the graphicFrame contains `<a:graphic><a:graphicData><a:tbl>` hierarchy
  - GraphicFrame position uses `<p:xfrm>` (not `<a:xfrm>`) at the graphicFrame level, separate from spPr xfrm
  - Cell merge in PPTX uses `gridSpan` attribute on `<a:tc>` for colspan, `rowSpan` for rowspan, and `hMerge`/`vMerge` attributes on continuation cells
  - Continuation cells (hMerge/vMerge) are represented with col_span=0 / row_span=0 to match the existing IR convention
  - `parse_pptx_table()` is a standalone sub-parser called from the main slide parser — keeps the main event loop from becoming unwieldy
  - Cell property XML (`<a:tcPr>`) contains both background fills and border lines — need separate SolidFillCtx tracking for cell fill vs border line fill
  - The existing `generate_table()` function works unchanged for tables on fixed pages — just wrap in `#place()` via `generate_fixed_element()`
---

## 2026-02-27 - US-027: XLSX parser - cell formatting (font, color, background, borders)
- What was implemented:
  - Added `parse_argb_color()` to convert ARGB hex strings (e.g. "FFFF0000") to IR Color
  - Added `border_style_to_width()` mapping Excel border styles to point widths (hair=0.25, thin=0.5, medium=1.0, thick=2.0)
  - Added `extract_cell_text_style()` to extract font properties (name, size, bold, italic, underline, strikethrough, color) from umya cell style
  - Added `extract_cell_background()` to extract cell fill/background color
  - Added `extract_border_side()` and `extract_cell_borders()` for per-side border extraction
  - Added row height extraction via `sheet.get_row_dimension()` with `get_custom_height()` filter
  - Wired all formatting into the main parse loop: TextStyle on runs, background/border on TableCell, height on TableRow
  - 8 new tests: bold text, italic text, font color, font name+size, background fill, borders (top+bottom), row height, combined formatting, no-formatting defaults
- Files changed:
  - `crates/office2pdf/src/parser/xlsx.rs` — formatting extraction functions + wired into parse loop + 8 tests
  - `scripts/ralph/prd.json` — US-027 passes: true
- Dependencies added: none
- **Learnings for future iterations:**
  - umya-spreadsheet `Cell::get_style()` returns `&Style` (not Option); `Style::get_font()` returns `Option<&Font>`, `get_borders()` returns `Option<&Borders>`
  - Font default values: name="Calibri", size=11.0, bold=false — filter these out to avoid cluttering IR with Excel defaults
  - Color format is ARGB (8 hex chars): first 2 chars = alpha (skip), next 6 = RGB. "FF000000" = opaque black (default text color, skip)
  - `get_background_color()` is a convenience: actually reads `fill.pattern_fill.foreground_color` from style
  - Border style mapping: "none" → skip, "hair" → 0.25pt, "thin" → 0.5pt, "medium" → 1.0pt, "thick" → 2.0pt
  - Row height: `sheet.get_row_dimension(&row_idx)` returns `Option<&Row>`; only use when `get_custom_height()` is true (otherwise it's Excel's auto-calculated default)
  - `set_background_color()` on Style (for test setup) is a shortcut that creates a solid pattern fill with foreground color
---

## 2026-02-27 - US-028: XLSX parser - number formats (currency, percentage, date)
- What was implemented:
  - Switched cell value extraction from `cell.get_value().to_string()` (raw) to `cell.get_formatted_value()` (formatted) in XLSX parser
  - umya-spreadsheet's built-in formatting engine handles all number format types: currency, percentage, dates, thousands separators, custom format strings
  - No additional dependencies or custom formatting code needed — umya-spreadsheet already implements the full OOXML number format specification
  - 8 new tests: currency format (USD), percentage (0%), percentage with decimals (0.00%), date (yyyy-mm-dd), thousands separator (#,##0), general format unchanged, built-in format ID, custom format string (0.000)
- Files changed:
  - `crates/office2pdf/src/parser/xlsx.rs` — one-line change (`get_value()` → `get_formatted_value()`) + 8 new tests
  - `scripts/ralph/prd.json` — US-028 passes: true
- Dependencies added: none
- **Learnings for future iterations:**
  - umya-spreadsheet `Cell::get_formatted_value()` applies the cell's number format automatically — no need for manual format parsing
  - The formatting is handled by `to_formatted_string()` in umya's `helper::number_format` module, which supports all standard OOXML format codes
  - `set_value_number(f64)` stores as `CellRawValue::Numeric` — required for number formats to work (vs `set_value("string")` which auto-detects type)
  - `set_number_format_id(4)` auto-looks up the format code from umya's built-in table, but the resulting format string may have slightly different precision than expected (e.g., "1,234.500" vs "1,234.50")
  - "General" format preserves simple numbers as-is — switching to `get_formatted_value()` is backward-compatible with existing tests
  - For test dates, use Excel serial numbers (e.g., 45306) with `set_value_number()` and a date format code
---
