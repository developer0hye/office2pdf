# Ralph Progress Log
Started: 2026-02-26

## Codebase Patterns
- **Typst compilation**: Use `MinimalWorld` struct implementing `World` trait. Use `FontSearcher::new().include_system_fonts(false).search()` for embedded fonts only (Libertinus Serif, New Computer Modern, DejaVu Sans Mono). Create `Source` with `FileId::new(None, VirtualPath::new("main.typ"))`.
- **Typst codegen structure**: Each FlowPage emits `#set page(...)` then paragraphs. Text runs use `#text(props)[content]` for styling. Underline/strikethrough wrap with `#underline[...]`/`#strike[...]`. Special chars (`#`, `*`, `_`, `$`, etc.) must be escaped with `\`.
- **IR module imports**: Style types (Alignment, Color, TextStyle, ParagraphStyle, LineSpacing) are re-exported via `crate::ir::*` — do NOT import from `crate::ir::style::` (private module).
- **Quality gates**: Always run `cargo fmt --all -- --check`, `cargo clippy --workspace -- -D warnings`, `cargo test --workspace`, `cargo check --workspace` before committing. Use `writeln!` not `write!(...\n)` per clippy.
- **f64 formatting**: Use helper `format_f64()` to strip unnecessary trailing zeros (e.g., `72` not `72.0`).
- **Pipeline testing**: Use `office2pdf::render_document(&doc)` to test IR → PDF without needing parsers. Construct `Document` with mock `FlowPage`/`FixedPage`/`TablePage` data.
- **Typst table codegen**: Use `#table(columns: (Wpt, ...), ...)` with cells as `[content]` (simple) or `table.cell(props)[content]` (when colspan/rowspan/fill/stroke needed). Cell content uses `generate_run()` directly (no block wrapper). Borders: `stroke: (top: 1pt + rgb(r, g, b), ...)`. Background: `fill: rgb(r, g, b)`. Merging: `colspan: N`, `rowspan: N`.
- **docx-rs reading**: `docx_rs::read_docx(&[u8])` → `Docx`. Access `docx.document.children` (Vec<DocumentChild>). Paragraphs: `DocumentChild::Paragraph(Box<Paragraph>)`. Runs: `ParagraphChild::Run(Box<Run>)`. Text: `RunChild::Text(Text)` → `t.text`. Tab: `RunChild::Tab`. Break: `RunChild::Break`.
- **docx-rs private fields**: `PageSize` (w, h), `Bold` (val), `Italic` (val), `Sz` (val), `Color` (val), `Underline` (val), `RunFonts` (ascii, hi_ansi, etc.) all have private fields. Use `serde_json::to_value()` to extract values since they implement Serialize. **IMPORTANT**: These types serialize as their *direct inner value* (e.g. `Bold` → `true`, `Sz` → `24`, `Color` → `"FF0000"`), NOT as `{"val": ...}`. Use `json.as_bool()`, `json.as_f64()`, `json.as_str()` directly. `RunFonts` serializes as an object with `ascii`, `hi_ansi`, etc. fields. `Strike` has `pub val: bool` — accessible directly without serde.
- **DOCX units**: Page size and margins in OOXML are in twips (1 twip = 1/20 pt). Convert: `value_twips / 20.0 = points`. PageMargin fields are public i32. docx-rs default page size: 11906 x 16838 twips (A4).
- **Test DOCX creation**: Use `docx_rs::Docx::new().add_paragraph(...)`, then `.build().pack(&mut Cursor::new(Vec::new()))` to get bytes. Use `Cursor::into_inner()` to extract.
- **Typst FixedPage codegen**: Slides use `#set page(width: Wpt, height: Hpt, margin: 0pt)`. Elements use `#place(top + left, dx: Xpt, dy: Ypt)[...]` for absolute positioning. TextBox wraps content in `#block(width: Wpt, height: Hpt)[...]`. Shapes: `#rect(width, height, fill?, stroke?)`, `#ellipse(...)`, `#line(start, end, stroke?)`. Images use existing `generate_image()` inside place.
- **Typst TablePage codegen**: `generate_table_page()` calls `write_page_setup()` + `generate_table()`. Reuses all existing table infrastructure (cell merging, borders, backgrounds, column widths). TablePage = page setup + a single Table element.
- **PPTX parsing**: Use `zip` + `quick-xml` (both already transitive deps, no new downloads). PPTX is a ZIP: `ppt/presentation.xml` (slide size + slide refs via `<p:sldSz cx cy>` + `<p:sldId r:id>`), `ppt/_rels/presentation.xml.rels` (rId → slide path), `ppt/slides/slideN.xml` (shapes). Parse with `ZipArchive::new(Cursor::new(data))` → `read_zip_entry()` → `quick_xml::Reader::from_str()`.
- **PPTX slide XML structure**: Shapes at `<p:spTree>/<p:sp>`. Position/size: `<a:xfrm><a:off x y/><a:ext cx cy/></a:xfrm>` (EMU ÷ 12700 = points). Text: `<p:txBody>/<a:p>/<a:r>/<a:t>`. Run props: `<a:rPr b="1" i="1" u="sng" strike="sngStrike" sz="1800">` (sz in hundredths of pt). Font color: `<a:solidFill><a:srgbClr val="RRGGBB"/></a:solidFill>`. Font family: `<a:latin typeface="..."/>`. Para alignment: `<a:pPr algn="ctr|l|r|just"/>`.
- **Test PPTX creation**: Build ZIP in-memory with `zip::ZipWriter::new(Cursor::new(Vec::new()))`. Need `[Content_Types].xml`, `_rels/.rels`, `ppt/presentation.xml`, `ppt/_rels/presentation.xml.rels`, and `ppt/slides/slideN.xml`. Standard 4:3 size: 9144000 × 6858000 EMU = 720pt × 540pt.
- **quick-xml 0.38 API**: Use `Reader::from_str(xml)`, `reader.read_event()` → `Event::Start/Empty/End/Text/Eof`. `BytesText::xml_content()` (NOT `unescape()`!) for text decoding. `BytesStart::local_name().as_ref()` for element name. Attributes: iterate `e.attributes().flatten()`, match `attr.key.as_ref()` (full name like `r:id`) or `attr.key.local_name().as_ref()` (local). `attr.unescape_value()` for string values.
- **PPTX shapes**: `<p:sp>` without text body → Shape IR element. Geometry from `<a:prstGeom prst="rect|ellipse|line">`. Fill color: `<p:spPr><a:solidFill><a:srgbClr val="RRGGBB"/></a:solidFill>`. Border: `<a:ln w="12700"><a:solidFill>...</a:solidFill></a:ln>` (w in EMU, ÷12700 → pt). Use `SolidFillCtx` enum to distinguish shape fill vs line fill vs run fill contexts.
- **PPTX images**: `<p:pic>` element. Position/size from `<p:spPr><a:xfrm>`. Image ref: `<a:blip r:embed="rId3"/>`. Resolve rId via slide .rels file (`ppt/slides/_rels/slideN.xml.rels`), then read image bytes from ZIP. Image format detected from file extension.
- **PPTX slide .rels**: Path pattern: `ppt/slides/_rels/slideN.xml.rels`. Image targets are relative paths like `../media/image1.png`. Use `resolve_relative_path()` to compute full ZIP path from slide directory.
- **docx-rs image handling**: Images in document tree: `RunChild::Drawing(Box<Drawing>)` → `Drawing.data = Some(DrawingData::Pic(pic))`. Image binary data: stored in `Docx.images` as `Vec<(id, path, Image, Png)>` — match `pic.id` to look up data. `pic.image` is empty when reading (only used during writing). Dimensions: `pic.size = (w_emu, h_emu)` in EMU. Convert: EMU ÷ 12700 = points. All images converted to PNG by docx-rs.
- **Test images for docx-rs**: Use `make_test_bmp()` to create a minimal 1×1 BMP, then `Pic::new(&bmp_data)` which processes through the `image` crate. Do NOT use `Pic::new_with_dimensions()` with raw PNG bytes for round-trip tests — the `image` crate may fail to decode minimal hand-crafted PNGs during `read_docx()`.
- **Image codegen**: `generate_typst()` returns `TypstOutput { source: String, images: Vec<ImageAsset> }`. Images get virtual paths `img-N.ext` via `GenCtx`. `compile_to_pdf(source, &images)` passes images to `MinimalWorld` which serves them via `World::file()`. Image markup: `#image("img-0.png", width: Wpt, height: Hpt)`.
- **Valid test PNG**: For tests that compile Typst with images, use `make_test_png()` helper which builds a 1x1 PNG with correct CRC32 checksums. For codegen-only tests, any byte slice works since Typst doesn't validate during codegen.
---

## 2026-02-26 - US-001
- **What was implemented**: Typst rendering pipeline — IR Document to Typst markup generation (typst_gen.rs) and Typst compilation to PDF bytes (pdf.rs)
- **Files changed**:
  - `crates/office2pdf/Cargo.toml` — added typst, typst-pdf, typst-kit, comemo deps
  - `crates/office2pdf/src/render/typst_gen.rs` — full implementation: FlowPage codegen with text/paragraph styling
  - `crates/office2pdf/src/render/pdf.rs` — full implementation: MinimalWorld + compile + PDF export
- **Dependencies added**: typst 0.14, typst-pdf 0.14, typst-kit 0.14 (fonts feature), comemo 0.5
- **Learnings for future iterations:**
  - `Library::default()` requires `use typst::LibraryExt` trait in scope
  - `Bytes::new(vec)` is the constructor for typst's Bytes type (not `Bytes::from`)
  - Typst embedded fonts (with typst-kit `fonts` feature) include 3 font families — enough for basic rendering without system fonts
  - Paragraph alignment in Typst: `#align(center)[...]` for left/center/right, `#set par(justify: true)` for justify
  - Line spacing: `#set par(leading: Xem)` for proportional, `#set par(leading: Xpt)` for exact
---

## 2026-02-26 - US-002
- **What was implemented**: Wired conversion pipeline in library API. Added `render_document()` public function (IR → Typst → PDF). Refactored `convert_bytes()` to use it. Added 12 comprehensive unit tests.
- **Files changed**:
  - `crates/office2pdf/src/lib.rs` — added `render_document()`, comprehensive pipeline tests with mock IR documents
- **Dependencies added**: None
- **Learnings for future iterations:**
  - `render_document()` is the key testable pipeline entry point — construct IR manually to test rendering without needing actual file parsers
  - Pipeline stages: `parser.parse(data)` → `render::typst_gen::generate_typst(&doc)` → `render::pdf::compile_to_pdf(&typst_source)`
  - Empty Document (no pages) produces valid PDF (empty page) — Typst handles this gracefully
---

## 2026-02-26 - US-003
- **What was implemented**: DocxParser — basic text extraction from DOCX files. Extracts paragraphs with text runs, page size via serde, and margins from section properties.
- **Files changed**:
  - `crates/office2pdf/Cargo.toml` — added docx-rs 0.4, serde 1, serde_json 1
  - `crates/office2pdf/src/parser/docx.rs` — full implementation: DocxParser with 11 unit tests
- **Dependencies added**: docx-rs 0.4 (DOCX parsing), serde 1 + serde_json 1 (extract private fields from docx-rs types via serialization)
- **Learnings for future iterations:**
  - docx-rs PageSize has private fields (w, h) with no getters — must serialize to JSON to extract values
  - PageMargin fields are public i32 (top, left, bottom, right, header, footer, gutter)
  - DOCX `DocumentChild::Paragraph` wraps in `Box<Paragraph>` — all major types are boxed
  - Empty runs (no RunChild::Text) should be filtered out to avoid empty Run IR elements
  - docx-rs default page is A4 (11906 x 16838 twips)
  - Test DOCX creation: `Docx::new().add_paragraph(p).build().pack(&mut cursor)`
---

## 2026-02-26 - US-004
- **What was implemented**: DocxParser inline formatting extraction — bold, italic, underline, strikethrough, font name, font size, and font color from DOCX run properties.
- **Files changed**:
  - `crates/office2pdf/src/parser/docx.rs` — added `extract_run_style()`, `extract_bool_prop()`, `parse_hex_color()` functions; wired into `convert_paragraph()`; added 10 new tests
- **Dependencies added**: None
- **Learnings for future iterations:**
  - docx-rs types with private `val` fields (Bold, Italic, Sz, Color, Underline) serialize as their direct inner value via serde, NOT as `{"val": ...}` objects. Use `json.as_bool()`, `json.as_f64()`, `json.as_str()` directly.
  - `RunFonts` serializes as an object with named fields (`ascii`, `hi_ansi`, `east_asia`, `cs`) — use `json.get("ascii")` etc.
  - `Strike` is unique: it has `pub val: bool` so no serde needed.
  - Font size in docx-rs `Sz` is in half-points. Divide by 2.0 to get points for IR.
  - Underline type is a string ("single", "double", etc.). Map to `Some(true)` unless the value is "none".
  - Builder API for test DOCX runs: `.bold()`, `.italic()`, `.underline("single")`, `.strike()`, `.size(24)`, `.color("FF0000")`, `.fonts(RunFonts::new().ascii("Arial"))`
- **docx-rs paragraph properties**: `Paragraph.property` (public `ParagraphProperty`). Fields: `alignment` (`Option<Justification>`, serializes as string like "center"/"right"/"both"/"left"), `indent` (`Option<Indent>`, public fields: `start`/`end` in twips, `special_indent` as `SpecialIndentType::FirstLine(i32)`/`Hanging(i32)`), `line_spacing` (`Option<LineSpacing>`, private fields, use serde → JSON keys: `lineRule`, `line`, `before`, `after`), `page_break_before` (`Option<bool>`, direct access).
- **OOXML line spacing units**: Auto mode: `line` is in 240ths of a line (240=single, 480=double). Exact/AtLeast mode: `line` is in twips (÷20 → points). `before`/`after` always in twips.
- **Paragraph builder API**: `.align(AlignmentType::Center)`, `.indent(left, special_indent, end, start_chars)`, `.line_spacing(LineSpacing::new().line_rule(...).line(...).before(...).after(...))`, `.page_break_before(true)`.
---

## 2026-02-26 - US-005
- **What was implemented**: DocxParser paragraph formatting extraction — alignment, indentation (left/right/first-line/hanging), line spacing (auto/proportional and exact), space before/after, and page break before.
- **Files changed**:
  - `crates/office2pdf/src/parser/docx.rs` — refactored `convert_paragraph()` → `convert_paragraph_blocks()` (handles page breaks); added `extract_paragraph_style()`, `extract_indent()`, `extract_line_spacing()` functions; added 13 new tests
- **Dependencies added**: None
- **Learnings for future iterations:**
  - `Justification` serializes as a plain string (e.g., "center", "right", "both") — use `.as_str()` directly
  - `Indent` has public fields: `start` (left), `end` (right), `special_indent` (`SpecialIndentType::FirstLine(i32)` or `Hanging(i32)`) — all in twips
  - `LineSpacing` has private fields — serialize to JSON. Keys: `lineRule` (string), `line` (i32), `before` (u32), `after` (u32)
  - Auto line spacing: 240ths of a line (240=single, 360=1.5×, 480=double). Exact/AtLeast: twips (÷20 → points)
  - Page break before is `Option<bool>` on `ParagraphProperty`, accessed directly. Emit `Block::PageBreak` before the paragraph in IR output.
  - Hanging indent maps to negative first-line indent in IR
---

## 2026-02-26 - US-006
- **What was implemented**: Typst codegen table rendering support — generates `#table(...)` markup from IR Table elements with full styling support.
- **Files changed**:
  - `crates/office2pdf/src/render/typst_gen.rs` — added `generate_table()`, `generate_table_cell()`, `write_cell_params()`, `format_cell_stroke()`, `format_border_side()`, `generate_cell_content()`, `generate_cell_paragraph()` functions; updated `generate_block()` to dispatch `Block::Table`; added 13 new tests
- **Dependencies added**: None
- **Learnings for future iterations:**
  - Typst table syntax: `#table(columns: (W1pt, W2pt), [cell], [cell], ...)`. Use `table.cell(props)[content]` only when cell has special properties (merging, fill, stroke).
  - Cell content in Typst is in markup mode inside `[...]` — `#text(...)` and other Typst commands work inside.
  - For cell content, use `generate_run()` directly without the paragraph block wrapper (no `#block()` or `#align()` inside cells for basic content).
  - Border sides format: `stroke: (top: 1pt + rgb(r, g, b), bottom: ...)`. Each side is `Wpt + rgb(r,g,b)`.
  - When no column_widths provided, Typst auto-sizes columns — just omit `columns:` parameter.
- **docx-rs table API**: `DocumentChild::Table(Box<Table>)`. Rows: `table.rows` → `Vec<TableChild::TableRow(TableRow)>`. Cells: `row.cells` → `Vec<TableRowChild::TableCell(TableCell)>`. Cell content: `cell.children` → `Vec<TableCellContent::Paragraph(Paragraph)|Table(Table)>`. Column widths: `table.grid` → `Vec<usize>` (public, twips).
- **docx-rs table cell properties (serde)**: `TableCellProperty` fields are private. Serialize to JSON: `gridSpan` → integer, `verticalMerge` → `"restart"`/`"continue"` string, `shading` → `{"fill": "RRGGBB", "color": "auto", "shdType": "clear"}`, `borders` → `{"top": {"borderType": "single", "color": "RRGGBB", "size": N, ...}, ...}`. Border `size` is in eighths of a point (÷8 → points).
- **vMerge resolution**: Restart starts a merge; Continue cells below are skipped. Count consecutive Continue cells at same column index to compute rowspan. Use a two-pass approach: (1) extract RawCells with col_index/vmerge info, (2) resolve spans and build IR rows.
- **Table builder API (tests)**: `Table::new(vec![TableRow::new(vec![TableCell::new().add_paragraph(p)])]).set_grid(vec![2000])`. Colspan: `.grid_span(N)`. Rowspan: `.vertical_merge(VMergeType::Restart)` + `.vertical_merge(VMergeType::Continue)`. Background: `.shading(Shading::new().fill("FF0000"))`. Borders: `.set_border(TableCellBorder::new(TableCellBorderPosition::Top).size(8).color("FF0000"))`. Add to doc: `Docx::new().add_table(table)`.
---

## 2026-02-26 - US-007
- **What was implemented**: DocxParser table extraction — extracts tables from DOCX files into IR Table elements with full support for cell content, column widths, colspan (gridSpan), rowspan (vMerge restart/continue), cell borders, and background colors.
- **Files changed**:
  - `crates/office2pdf/src/parser/docx.rs` — added `convert_table()`, `extract_raw_rows()`, `resolve_vmerge_and_build_rows()`, `count_vmerge_span()`, `extract_cell_content()`, `extract_cell_borders()`, `extract_cell_shading()` functions; updated `parse()` to handle `DocumentChild::Table`; added 11 new tests
- **Dependencies added**: None
- **Learnings for future iterations:**
  - `TableCellProperty` fields (gridSpan, verticalMerge, borders, shading) are all private — must serialize to JSON via serde to extract
  - `gridSpan` serializes as a direct integer (e.g., `3`), `verticalMerge` as a string ("restart"/"continue")
  - `Shading.fill` is the background color hex string; skip "auto" and "FFFFFF" as transparent
  - Border `size` is in eighths of a point (divide by 8 to get points)
  - vMerge requires a two-pass approach: (1) extract raw cells with column indices and vmerge state, (2) resolve restart cells to rowspan by counting consecutive continue cells below
  - `table.grid` (column widths in twips) is public `Vec<usize>` — no serde needed
  - `TableChild::TableRow` and `TableRowChild::TableCell` are the only variants — can use `let` binding directly
  - docx-rs `TableCellBorders` defaults include insideH/insideV borders even when only top/bottom set explicitly — extract only top/bottom/left/right for IR
---

## 2026-02-26 - US-008
- **What was implemented**: Typst codegen image rendering support — generates `#image("img-N.ext", width: Wpt, height: Hpt)` markup from IR ImageData elements, with embedded image assets passed through to the Typst compiler.
- **Files changed**:
  - `crates/office2pdf/src/ir/elements.rs` — added `ImageFormat::extension()` method
  - `crates/office2pdf/src/render/typst_gen.rs` — added `ImageAsset`, `TypstOutput`, `GenCtx` types; changed `generate_typst()` to return `TypstOutput`; threaded `GenCtx` through block-level functions; implemented `generate_image()`; added 10 new image codegen tests; updated 27 existing tests for new return type
  - `crates/office2pdf/src/render/pdf.rs` — changed `compile_to_pdf()` to accept `&[ImageAsset]`; updated `MinimalWorld` to store and serve image files via `World::file()`; added `test_compile_with_embedded_image` test
  - `crates/office2pdf/src/lib.rs` — updated `render_document()` to pass `TypstOutput.images` through to `compile_to_pdf()`
- **Dependencies added**: None
- **Learnings for future iterations:**
  - Typst `#image("path")` resolves the path via `World::file()` — virtual paths like `img-0.png` work as long as the World serves matching data
  - `TypstOutput` struct bundles source markup + image assets, keeping the API clean
  - `GenCtx` context struct avoids threading multiple params through every function — just `&mut GenCtx` for all image-related state
  - For PNG test data in pdf.rs, CRC32 must be computed correctly per chunk — hand-crafted bytes break easily. Use a `make_test_png()` helper with proper CRC32 calculation.
  - `ImageFormat::extension()` maps Png→"png", Jpeg→"jpeg", Gif→"gif", Bmp→"bmp", Tiff→"tiff"
  - Image codegen tests only need arbitrary bytes (codegen doesn't validate image data); PDF compilation tests need valid image files
---

## 2026-02-26 - US-009
- **What was implemented**: DocxParser image extraction — extracts inline images from DOCX files into IR ImageData elements with PNG binary data and EMU-to-points dimensions.
- **Files changed**:
  - `crates/office2pdf/src/parser/docx.rs` — added `ImageMap` type alias, `build_image_map()`, `emu_to_pt()`, `extract_drawing_image()` functions; updated `convert_paragraph_blocks()` to detect `RunChild::Drawing` with `DrawingData::Pic`; threaded `ImageMap` through `convert_table()`, `extract_raw_rows()`, `extract_cell_content()`; added 7 image extraction tests
- **Dependencies added**: None
- **Learnings for future iterations:**
  - `Docx.images` stores `(id, path, Image(original_bytes), Png(png_bytes))` — populated by `add_image()` which requires `image::load_from_memory()` to succeed on the raw ZIP data
  - `Pic.image` is EMPTY when reading a DOCX (only used during writing) — must use `Docx.images` to get binary data
  - `Pic.id` is the relationship ID (e.g., "rIdImage1") that maps to entries in `Docx.images`
  - `Pic.size` is `(u32, u32)` in EMU; EMU ÷ 12700 = points
  - **CRITICAL for testing**: `Pic::new_with_dimensions(raw_bytes, w, h)` stores bytes as-is; when round-tripping through ZIP, `image::load_from_memory()` must decode them. Hand-crafted minimal PNGs often fail this. Use `make_test_bmp()` + `Pic::new()` which processes through the `image` crate, guaranteeing valid PNG in the ZIP.
  - docx-rs converts ALL images to PNG internally (via `image` crate) — so `ImageFormat::Png` is always correct for parsed DOCX images
  - Inline images appear as `RunChild::Drawing(Box<Drawing>)` → `Drawing.data = Some(DrawingData::Pic(pic))`
  - Images are emitted as `Block::Image` before the paragraph in which they appear (since our IR doesn't support inline images within paragraphs)
---

## 2026-02-26 - US-010
- **What was implemented**: Typst codegen FixedPage support for slides — absolute positioning of text boxes, shapes (rectangle, ellipse, line), and images using Typst's `#place()` function.
- **Files changed**:
  - `crates/office2pdf/src/render/typst_gen.rs` — added `generate_fixed_page()`, `generate_fixed_element()`, `generate_shape()`, `write_shape_params()` functions; wired `Page::Fixed` in `generate_typst()`; added 12 new tests
- **Dependencies added**: None
- **Learnings for future iterations:**
  - Typst `#place(top + left, dx: Xpt, dy: Ypt)[content]` is the way to do absolute positioning on a page
  - Slides should use `margin: 0pt` since all elements are absolutely positioned
  - TextBox elements need a `#block(width, height)[...]` wrapper to constrain text flow
  - Shapes map directly to Typst primitives: `#rect()`, `#ellipse()`, `#line()`
  - Shape fill: `fill: rgb(r, g, b)`, stroke: `stroke: Wpt + rgb(r, g, b)`
  - Line uses `start: (0pt, 0pt), end: (x2pt, y2pt)` — coordinates relative to placement position
  - `write!()` with trailing `\n` triggers clippy `write-with-newline` — always use `writeln!()` instead

## 2026-02-26 - US-011
- **What was implemented**: PptxParser — extracts slides from PPTX files as FixedPage elements with positioned text boxes. Uses zip + quick-xml for direct PPTX ZIP/XML parsing (no ppt-rs — it's write-only).
- **Files changed**:
  - `crates/office2pdf/Cargo.toml` — added zip 0.6, quick-xml 0.38 (both already transitive deps, no new downloads)
  - `crates/office2pdf/src/parser/pptx.rs` — full implementation: PptxParser with ZIP reading, presentation.xml parsing, rels parsing, slide XML state-machine parser, text formatting extraction; 16 unit tests
- **Dependencies added**: zip 0.6 (ZIP reading), quick-xml 0.38 (XML parsing) — both already in dependency tree as transitive deps of docx-rs and typst
- **Learnings for future iterations:**
  - `ppt-rs` is a write-only crate (creates PPTX, cannot read them). For reading, use zip + quick-xml directly.
  - PPTX is a well-structured ZIP with predictable XML paths — no need for a specialized parsing crate
  - quick-xml 0.38 changed `BytesText` API: use `xml_content()` instead of `unescape()` for text decoding
  - `BytesStart::local_name()` strips namespace prefix (`a:off` → `off`). Use `attr.key.as_ref()` for full qualified name matching (`r:id`).
  - PPTX font size is in hundredths of a point (e.g., 1800 = 18pt) — different from DOCX (half-points)
  - PPTX uses same EMU units as DOCX for positions/sizes (÷12700 → points)
  - State machine approach with boolean flags works well for streaming XML parsing of slide shapes
  - Track `shape_depth` to handle nested `<p:sp>` inside group shapes without confusion
  - `<a:rPr>` can be either Empty (self-closing) or Start (with children like `<a:solidFill>`) — handle both
---

## 2026-02-26 - US-012
- **What was implemented**: PptxParser shape extraction (rectangle, ellipse, line) and image extraction from PPTX slides. Shapes without text body are emitted as `FixedElementKind::Shape` with geometry, fill, and border. Images from `<p:pic>` elements resolved via slide .rels and loaded from ZIP.
- **Files changed**:
  - `crates/office2pdf/src/parser/pptx.rs` — added `SolidFillCtx` enum, `SlideImageMap` type, `load_slide_images()`, `resolve_relative_path()`, `image_format_from_ext()`, `prst_to_shape_kind()` functions; extended `parse_slide_xml()` with shape/image state tracking; added 13 new tests (7 shape + 6 image)
- **Dependencies added**: None
- **Learnings for future iterations:**
  - `SolidFillCtx` enum cleanly distinguishes between shape fill, border fill, and text run fill — avoids bug-prone nested boolean tracking
  - Shapes with text body → TextBox; shapes without → Shape. Check `paragraphs.iter().any(|p| !p.runs.is_empty())` to detect actual text content (empty paragraphs don't count)
  - `<a:prstGeom prst="...">` can be either Start element (with children like `<a:avLst/>`) or Empty element — handle both in the XML parser
  - `<a:ln w="12700">` border width is in EMU (÷12700 → points), same as other PPTX measurements
  - Image resolution: `<a:blip r:embed="rIdN"/>` → slide .rels (`ppt/slides/_rels/slideN.xml.rels`) → relative path (`../media/image1.png`) → `resolve_relative_path()` → absolute ZIP path (`ppt/media/image1.png`)
  - `resolve_relative_path()` handles `..` components for navigating up from slide directory to media directory
  - `image_format_from_ext()` returns None for non-image paths, serving as both format detector and image filter
---

## 2026-02-26 - US-013
- **What was implemented**: Typst codegen TablePage support for spreadsheets. Added `generate_table_page()` function that emits page setup (size + margins) and delegates to existing `generate_table()` for the table content.
- **Files changed**:
  - `crates/office2pdf/src/render/typst_gen.rs` — added `generate_table_page()` function, added `TablePage` import, wired `Page::Table` arm in `generate_typst()`, added 8 new tests
- **Dependencies added**: None
- **Learnings for future iterations:**
  - TablePage codegen is minimal because it reuses all existing table infrastructure from US-006 (generate_table, generate_table_cell, write_cell_params, etc.)
  - The only new function needed was `generate_table_page()` which calls `write_page_setup()` + `generate_table()`
  - TablePage test helpers: `make_table_page(name, width, height, margins, table)` and `make_simple_table(rows: Vec<Vec<&str>>)` for quick test setup
  - `-` is NOT a Typst special character — dates like "2024-01-15" pass through unescaped
---
