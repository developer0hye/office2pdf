## Codebase Patterns
- **Typst compilation**: Use `MinimalWorld` struct implementing `World` trait. Use `FontSearcher::new().include_system_fonts(false).search()` for embedded fonts only (Libertinus Serif, New Computer Modern, DejaVu Sans Mono). Create `Source` with `FileId::new(None, VirtualPath::new("main.typ"))`.
- **Typst codegen structure**: Each FlowPage emits `#set page(...)` then paragraphs. Text runs use `#text(props)[content]` for styling. Underline/strikethrough wrap with `#underline[...]`/`#strike[...]`. Special chars (`#`, `*`, `_`, `$`, etc.) must be escaped with `\`.
- **IR module imports**: Style types (Alignment, Color, TextStyle, ParagraphStyle, LineSpacing) are re-exported via `crate::ir::*` — do NOT import from `crate::ir::style::` (private module).
- **Quality gates**: Always run `cargo fmt --all -- --check`, `cargo clippy --workspace -- -D warnings`, `cargo test --workspace`, `cargo check --workspace` before committing. Use `writeln!` not `write!(...\n)` per clippy.
- **f64 formatting**: Use helper `format_f64()` to strip unnecessary trailing zeros (e.g., `72` not `72.0`).
- **Pipeline testing**: Use `office2pdf::render_document(&doc)` to test IR → PDF without needing parsers. Construct `Document` with mock `FlowPage`/`FixedPage`/`TablePage` data.
- **Typst table codegen**: Use `#table(columns: (Wpt, ...), ...)` with cells as `[content]` (simple) or `table.cell(props)[content]` (when colspan/rowspan/fill/stroke needed). Cell content uses `generate_run()` directly (no block wrapper). Borders: `stroke: (top: 1pt + rgb(r, g, b), ...)`. Background: `fill: rgb(r, g, b)`. Merging: `colspan: N`, `rowspan: N`.
- **docx-rs reading**: `docx_rs::read_docx(&[u8])` → `Docx`. Access `docx.document.children` (Vec<DocumentChild>). Paragraphs: `DocumentChild::Paragraph(Box<Paragraph>)`. Runs: `ParagraphChild::Run(Box<Run>)`. Text: `RunChild::Text(Text)` → `t.text`. Tab: `RunChild::Tab`. Break: `RunChild::Break`.
- **docx-rs private fields**: `PageSize` (w, h), `Bold` (val), `Italic` (val), `Sz` (val), `Color` (val), `Underline` (val), `RunFonts` (ascii, hi_ansi, etc.) all have private fields. Use `serde_json::to_value()` to extract values since they implement Serialize. **IMPORTANT**: These types serialize as their *direct inner value* (e.g. `Bold` → `true`, `Sz` → `24`, `Color` → `"FF0000"`), NOT as `{"val": ...}`. Use `json.as_bool()`, `json.as_f64()`, `json.as_str()` directly. `RunFonts` serializes as an object with `ascii`, `hi_ansi`, etc. fields. `Strike` has `pub val: bool` — accessible directly without serde.
- **DOCX units**: Page size and margins in OOXML are in twips (1 twip = 1/20 pt). Convert: `value_twips / 20.0 = points`. PageMargin fields are public i32. docx-rs default page size: 11906 x 16838 twips (A4).
- **Test DOCX creation**: Use `docx_rs::Docx::new().add_paragraph(...)`, then `.build().pack(&mut Cursor::new(Vec::new()))` to get bytes. Use `Cursor::into_inner()` to extract.
- **Typst FixedPage codegen**: Slides use `#set page(width: Wpt, height: Hpt, margin: 0pt)`. Elements use `#place(top + left, dx: Xpt, dy: Ypt)[...]` for absolute positioning. TextBox wraps content in `#block(width: Wpt, height: Hpt)[...]`. Shapes: `#rect(width, height, fill?, stroke?)`, `#ellipse(...)`, `#line(start, end, stroke?)`. Images use existing `generate_image()` inside place.
- **umya-spreadsheet merge API**: `sheet.get_merge_cells()` → `&[Range]`. Range has `get_coordinate_start_col/row()` and `get_coordinate_end_col/row()` → `Option<&ColumnReference/RowReference>`. Use `*ref.get_num()` for 1-indexed u32 coordinate. `sheet.add_merge_cells("A1:C5")` for test creation. Must expand `get_highest_column_and_row()` grid to include merge extents since that method only considers cells with data.
- **umya-spreadsheet reading**: `umya_spreadsheet::reader::xlsx::read_reader(Cursor::new(data), true)` → `Spreadsheet`. Sheets: `book.get_sheet_collection()`. Sheet name: `sheet.get_name()`. Cell: `sheet.get_cell((col, row))` → **IMPORTANT: tuple is (column, row), NOT (row, column)**. Cell value: `cell.get_value().to_string()`. Dimensions: `sheet.get_highest_column_and_row()` → `(max_col, max_row)`. Column width: `sheet.get_column_dimension_by_number(&col)` → `Option<&Column>`, then `col.get_width()` (Excel char units, ×7.0 → points).
- **Test XLSX creation**: `umya_spreadsheet::new_file()` → `Spreadsheet`. Set cell: `sheet.get_cell_mut("A1").set_value("text")`. Write: `umya_spreadsheet::writer::xlsx::write_writer(&book, &mut Cursor::new(Vec::new()))`. Multi-sheet: first sheet via `book.get_sheet_mut(&0)`, additional via `book.add_sheet(Worksheet::default())`.
- **Typst TablePage codegen**: `generate_table_page()` calls `write_page_setup()` + `generate_table()`. Reuses all existing table infrastructure (cell merging, borders, backgrounds, column widths). TablePage = page setup + a single Table element.
- **PPTX parsing**: Use `zip` + `quick-xml` (both already transitive deps, no new downloads). PPTX is a ZIP: `ppt/presentation.xml` (slide size + slide refs via `<p:sldSz cx cy>` + `<p:sldId r:id>`), `ppt/_rels/presentation.xml.rels` (rId → slide path), `ppt/slides/slideN.xml` (shapes). Parse with `ZipArchive::new(Cursor::new(data))` → `read_zip_entry()` → `quick_xml::Reader::from_str()`.
- **PPTX slide XML structure**: Shapes at `<p:spTree>/<p:sp>`. Position/size: `<a:xfrm><a:off x y/><a:ext cx cy/></a:xfrm>` (EMU ÷ 12700 = points). Text: `<p:txBody>/<a:p>/<a:r>/<a:t>`. Run props: `<a:rPr b="1" i="1" u="sng" strike="sngStrike" sz="1800">` (sz in hundredths of pt). Font color: `<a:solidFill><a:srgbClr val="RRGGBB"/></a:solidFill>`. Font family: `<a:latin typeface="..."/>`. Para alignment: `<a:pPr algn="ctr|l|r|just"/>`.
- **Test PPTX creation**: Build ZIP in-memory with `zip::ZipWriter::new(Cursor::new(Vec::new()))`. Need `[Content_Types].xml`, `_rels/.rels`, `ppt/presentation.xml`, `ppt/_rels/presentation.xml.rels`, and `ppt/slides/slideN.xml`. Standard 4:3 size: 9144000 × 6858000 EMU = 720pt × 540pt.
- **quick-xml 0.38 API**: Use `Reader::from_str(xml)`, `reader.read_event()` → `Event::Start/Empty/End/Text/Eof`. `BytesText::xml_content()` (NOT `unescape()`!) for text decoding. `BytesStart::local_name().as_ref()` for element name. Attributes: iterate `e.attributes().flatten()`, match `attr.key.as_ref()` (full name like `r:id`) or `attr.key.local_name().as_ref()` (local). `attr.unescape_value()` for string values.
- **PPTX shapes**: `<p:sp>` without text body → Shape IR element. Geometry from `<a:prstGeom prst="rect|ellipse|line">`. Fill color: `<p:spPr><a:solidFill><a:srgbClr val="RRGGBB"/></a:solidFill>`. Border: `<a:ln w="12700"><a:solidFill>...</a:solidFill></a:ln>` (w in EMU, ÷12700 → pt). Use `SolidFillCtx` enum to distinguish shape fill vs line fill vs run fill contexts.
- **PPTX images**: `<p:pic>` element. Position/size from `<p:spPr><a:xfrm>`. Image ref: `<a:blip r:embed="rId3"/>`. Resolve rId via slide .rels file (`ppt/slides/_rels/slideN.xml.rels`), then read image bytes from ZIP. Image format detected from file extension.
- **PPTX slide .rels**: Path pattern: `ppt/slides/_rels/slideN.xml.rels`. Image targets are relative paths like `../media/image1.png`. Use `resolve_relative_path()` to compute full ZIP path from slide directory.
- **docx-rs image handling**: Images in document tree: `RunChild::Drawing(Box<Drawing>)` → `Drawing.data = Some(DrawingData::Pic(pic))`. Image binary data: stored in `Docx.images` as `Vec<(id, path, Image, Png)>` — match `pic.id` to look up data. `pic.image` is empty when reading (only used during writing). Dimensions: `pic.size = (w_emu, h_emu)` in EMU. Convert: EMU ÷ 12700 = points. All images converted to PNG by docx-rs.
- **Test images for docx-rs**: Use `make_test_bmp()` to create a minimal 1×1 BMP, then `Pic::new(&bmp_data)` which processes through the `image` crate. Do NOT use `Pic::new_with_dimensions()` with raw PNG bytes for round-trip tests — the `image` crate may fail to decode minimal hand-crafted PNGs during `read_docx()`.
- **Image codegen**: `generate_typst()` returns `TypstOutput { source: String, images: Vec<ImageAsset> }`. Images get virtual paths `img-N.ext` via `GenCtx`. `compile_to_pdf(source, &images)` passes images to `MinimalWorld` which serves them via `World::file()`. Image markup: `#image("img-0.png", width: Wpt, height: Hpt)`.
- **Valid test PNG**: For tests that compile Typst with images, use `make_test_png()` helper which builds a 1x1 PNG with correct CRC32 checksums. For codegen-only tests, any byte slice works since Typst doesn't validate during codegen.
---

# Ralph Progress Log - Phase 2: P1 Features - Formatting, Styles, Font Fallback
Started: 2026년  2월 27일 금요일 00시 55분 34초 KST
---
